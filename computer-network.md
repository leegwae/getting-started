# computer-network

> 질문과 답변은 [이 레포지토리](https://github.com/leegwae/computer-network)에 정리된 텍스트에 기반합니다. 자세한 내용은 해당 레포지토리를 참고하세요.

## TOC

- [네트워크 기본](#네트워크-기본)
- [네트워크 계층 모델](#네트워크-계층-모델)
- [네트워크 계층](#네트워크-계층)
- [전송 계층 - TCP, UDP](#전송-계층)
- [HTTP](#HTTP)
- [HTTPS](#HTTPS)
- [DNS](#DNS)
- [인증과 인가](#인증과-인가)
- [기타](#기타)

## 네트워크 기본

### 네트워크, 인터넷, 웹에 대해 설명해주세요?

네트워크(network)는 전송 매체를 통해 연결되어 데이터를 교환하는 시스템의 모임이다. 인터넷(internet)은 컴퓨터로 이루어진 네트워크이다. 웹(WWW, W3, Web)은 인터넷에 연결된 호스트가 데이터를 주고 받을 수 있는 공간이다.

### 게이트웨이란 무엇인가요?

게이트웨이(gateway)는 네트워크 간의 연결을 수행하는 시스템이다. 라우터, 방화벽, 프록시 서버, 스위치 등이 속한다.

## 네트워크 계층 모델

### OSI 7 계층에 대해 설명해주세요?

OSI 7 계층은 국제 표준화 기구에서 네트워크 시스템이 갖춰야할 기능을 계층적으로 정의한 것이다. 물리 계층은 데이터를 전기 신호로 변환하여 전송 매체를 통해 전송한다. 데이터의 단위는 비트이며 대표적인 장비로 리피터, 케이블, 허브(L1 스위치)가 있다. 데이터 링크 계층은 전송 매체로 연결된(point-to-point) 두 노드 간의 신뢰성 있는 데이터의 전송을 보장한다. 대표적인 전송 프로토콜로 이더넷과 Wi-Fi가 있으며, 데이터의 단위는 프레임이고 헤더에 호스트를 구분하는 물리적 주소인 MAC 주소를 포함한다. 대표적인 장비로 브릿지, 스위치(L2 스위치) 등이 있다. 네트워크 계층은 라우팅을 담당하며 혼잡 제어 기능을 제공한다. 대표적인 데이터 전송 프로토콜로 IP가 있으며, 데이터의 단위는 패킷이고 헤더에 호스트를 구분하는 논리적 주소인 IP 주소를 포함한다. 대표적인 장비로 라우터(L3 스위치)가 있다. 전송 계층은 종단 연결된(end-to-end) 송수신 프로세스 간의 신뢰성 있는 데이터의 전송을 보장하고, 데이터를 분할하거나 병합한다. 데이터 전송 프로토콜로 TCP를 사용하는 경우, 오류 제어/흐름 제어/혼잡 제어를 제공하며 데이터의 단위는 세그먼트이다. UDP를 사용하는 경우, 오류 제어를 제공하며 데이터의 단위는 데이터그램이다. 헤더는 프로세스를 구분하는 포트 주소를 포함한다. 세션 계층은 송수신 프로세스가 통신할 수 있도록 세션 기능과 동기화 기능을 제공한다. 표현 계층은 표준으로 데이터를 변환하거나 암호화/복호화하고 압축한다. 응용 계층은 응용 프로세스가 동작하며 대표적인 프로토콜로 HTTP/HTTPS, FTP, DNS, SSH 등이 있다.

> - 오류 제어: 오류는 데이터가 분실되거나 변형되는 문제이다. 송신 호스트는 타임아웃으로 오류를 검출하고 재전송하며, 수신 호스트는 오류 검출 코드로 오류를 검출한다.
> - 흐름 제어: 수신 속도가 송신 속도보다 느린 경우 데이터 분실 오류가 발생할 수 있다. 이때 송신 프로세스가 타임아웃 기능을 사용하면 네트워크 전송 효율이 떨어진다. 흐름 제어는 수신 호스트가 수용할 수 있을 정도로 송신 호스트의 전송 속도를 조절하는 것이다.
> - 혼잡 제어: 혼잡은 네트워크에 패킷이 과도하여 전체 네트워크의 전송도가 떨어지는 현상이다. 혼잡 제어는 혼잡을 예방하거나 제거하는 기능이다.

### TCP/IP 모델에 대해 설명해주세요?

TCP/IP 모델은 네트워크 시스템의 기능을 4계층으로 정의한 것이다. 네트워크 액세스 계층은 OSI 7 계층에서 물리 계층과 데이터 링크 계층에 대응하며 LAN 카드와 LAN 카드 드라이버로 구현되어있다. 인터넷 계층은 OSI 7 계층에서 네트워크 계층에 대응한다. 전송 계층은 OSI 7 계층에서 전송 계층에 대응하며, TCP/UDP는 커널 내부에 구현되어있어 프로세스는 시스템 콜의 형태로 제공되는 소켓 인터페이스를 사용한다. 응용 계층은 OSI 7 계층에서 세션 계층, 표현 계층, 응용 계층에 대응한다.

### LAN과 LAN 카드에 대해 설명해주세요?

LAN(Local Area Network)은 동일한 건물(집, 회사, 학교 등)과 같이 한정된 지역 내에서 연결된 호스트들의 네트워크이다. LAN 카드는 호스트가 LAN이나 WLAN(Wireless LAN)에 연결될 수 있도록 하는 하드웨어이다. LAN 카드는 네트워크 상에서 LAN 카드를 고유하게 식별하는 MAC 주소를 가진다. LAN에 연결된 호스트들은 데이터 전송 프로토콜로 이더넷을, WLAN은 Wi-Fi를 사용한다.

> LAN 카드는 LAN 어댑터(LAN Adapter), 네트워크 어댑터(Network Adapter), 네트워크 인터페이스 카드(Network Interface Card; NIC) 등으로도 불리운다.

## 네트워크 계층

### ARP/RARP에 대해 설명해주세요?

ARP와 RARP는 데이터 링크 계층의 프로토콜이다. ARP(Address Resolution Protocol)은 IP 주소를 MAC 주소로 변환하는 프로토콜로 송신 호스트가 수신 호스트의 IP 주소에 대응하는 MAC 주소를 얻기 위해 사용한다. `ARP request`(ARP 클라이언트가 네트워크의 모든 호스트에게 브로드캐스팅)와 `ARP reply`(해당하는 호스트가 MAC 주소를 ARP 클라이언트에게 유니캐스팅)의 과정으로 이루어진다. RARP(Reverse ARP)는 MAC 주소를 IP 주소로 변환하는 프로토콜로 파일 시스템이 존재하지 않는 호스트가 자신의 IP 주소를 얻기 위해 사용한다(IP 주소는 파일에 보관된다). `RARP request`(RARP 클라이언트가 네트워크의 모든 호스트에게 브로드캐스팅)와 `RARP reply`(RARP 서버가 IP 주소를 RARP 클라이언트에게 유니캐스팅)의 과정으로 이루어진다.

### IP 주소에 대해 설명해주세요?

IP 주소는 네트워크에서 호스트를 식별하기 위해 사용하는 주소이다. IPv4 주소 체계를 기준으로 설명하면 32비트의 이진수이며 8비트씩 `.`로 구분하여 십진수로 표현한다. 클래스 기반 IP 주소 체계에서 IP 주소는 네트워크 대역에 따라 다섯 개의 네트워크 클래스로 나뉘는데, A/B/C는 유니캐스팅에, D는 멀티캐스팅에 사용하며 E는 연구 목적으로 예약되었다. A/B/C는 서브넷 마스크(`255.0.0.0`/`255.255.0.0`/`255.255.255.0`)를 사용하여 주소를 `network`와 `host` 필드로 나눈다.

### 서브네팅에 대해 설명해주세요?

서브네팅(subnetting)은 서브넷 마스크를 사용하여 네트워크를 서브넷(subnet)으로 분할하는 프로세스이다. 서브넷 마스크(subnet mask)는 IP 주소를 네트워크 주소와 호스트 주소로 구분하기 위해 사용한다. IP 주소 공간을 효율적으로 사용할 수 있다.

### 클래스 기반 IP 주소 체계의 문제와 해결 방법에 대해 알려주세요?

첫번째, 지원할 수 있는 호스트의 개수가 제한되어있어 비효율적이다. 예를 들어 호스트 개수가 300개인 네트워크는 최대 254개의 호스트를 지원하는 클래스 C를 사용할 수 없으므로 클래스 B를 사용해야한다. 그러나 클래스 B는 약 6만 5000개의 호스트를 지원하기 때문에 IP 주소 공간이 낭비된다. 두번째, 유사한 네트워크 접두사를 가진 네트워크들을 결합할 수 없다. 예를 들어 클래스 C 네트워크에 속하는 `192.168.1.0`과 `192.168.0.0`을 결합하고자 한다. 그러나 클래스 C의 서브넷 마스크가 `255.255.255.0`으로 고정되어있어 `192.168.1`과 `192.168.0`은 서로 다른 네트워크로 구분된다. 이를 해결하기 위해 IP 주소를 서브넷 마스크와 결합하여 표시하는 CIDR 표기법을 사용할 수 있다. CIDR 표기법은 IP 주소를 `IP주소/서브넷마스크비트수`로 표현한다.

> CIDR은 Classless Inter-Domain Routing의 약어이다.

### IPv4 주소 체계의 문제와 해결 방법에 대해 알려주세요?

IPv4 주소 고갈 문제를 해결하기 위해 public IP와 private IP를 사용하거나 IPv6 주소 체계를 사용한다.

### IPv6 주소 체계에 대해 설명해주세요?

IPv6 주소는 126비트의 이진수이며 16비트씩 `:`으로 구분하고 16진수로 표현한다.

### public IP와 private IP에 대해 설명해주세요?

public IP는 ISP(Internet Service Provider)에 의해 할당되는 고유한 주소로 네트워크 외부와 통신할 때 사용한다. private IP는 네트워크 관리자나 라우터에 의해 할당되며 해당 네트워크 내에서만 고유한 주소이다. 예를 들어 공유기를 통해 LAN에 연결된 호스트들은 공유기에 의해 private IP를 부여받으나 모두 동일한 public IP(공유기가 ISP로부터 할당받은 public IP)로 네트워크에 접속한다. 공유기는 NAT을 사용하여 public IP와 private IP를 상호 변환한다.

> ISP는 일반적으로 통신사를 가리킨다. 그 외에도 웹 호스팅을 제공하는 업체를 포함할 수 있다.

### private IP를 사용하면 어떤 이점을 얻을 수 있는가?

public IP는 외부에 공개되어있으므로 추적당할 위험이 있다. private IP를 사용하면 네트워크 외부로부터 오는 보안 공격은 public IP 하나만 주의하면 된다.

### static IP와 dynamic IP에 대해 설명해주세요?

static IP는 호스트에 고정적으로 부여되는 주소로 반납되기 전까지는 독점한다. 보안성이 우수하다. dynamic IP는 호스트에게 임시로 부여되는 주소로 대부분의 호스트는 부팅되거나 네트워크에 접속할 때마다 새로운 IP를 발급받는다.

> 컴퓨터는 부팅될 때 DHCP 프로토콜을 사용하여 DHCP 서버나 라우터로부터 IP 주소를 할당받는다

### 호스트가 dynamic IP를 발급받는 과정에 대해 설명해주세요? (DHCP에 대해 설명해주세요?)

DHCP(Dynamic Host Configuration Protocol)를 사용하면 호스트는 네트워크 연결에 필요한 설정들을 할당받을 수 있다. 이 설정은 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 등을 포함한다. `DHCP_DISCOVER`(DHCP 클라이언트가 DHCP 서버를 찾기 위해 브로드캐스팅), `DHCP_OFFER`(DHCP 서버가 풀에서 IP 주소를 골라 서브넷 마스크, 기본 게이트웨이, DNS 서버 등의 네트워크 설정과 함께 브로드캐스팅 혹은 유니캐스팅), `DHCP_REQEUST`(DHCP 클라이언트가 `DHCP_OFFER` 중 하나를 골라 브로드캐스팅), `DHCP_ACK`(DHCP 서버가 DHCP 클라이언트에게 승인을 브로드캐스팅 혹은 유니캐스팅)/`DHCP_NACK`(DHCP 서버가 DHCP 클라이언트에게 선점되었음을 브로드캐스팅 혹은 유니캐스팅)의 과정으로 이루어진다.

> DHCP 서버는 DHCP 메시지의 브로드캐스트 플래그의 값에 따라 DHCP 클라이언트에게 브로드캐스팅 혹은 유니캐스팅한다.

> - 기본 게이트웨이(Default Gateway)는 호스트가 네트워크에 접속할 때 사용하는 게이트웨이이다.
> - DNS 서버는 DNS Resolver가 질의하는 DNS 서버로, 로컬 DNS 서버라고도 한다.
> - Windows 운영체제의 경우 `ipconfig /all` 명령어를 통해 네트워크 연결 설정을 볼 수 있는데, 기본 게이트웨이, DNS 서버, DHCP 서버가 모두 공유기의 주소로 설정되어있는 것을 볼 수 있다. 이것은 현대의 공유기가 라우터, 방화벽, DHCP 서버, DNS 서버, 스위치, 무선 액세스 포인트(AP; Wireless Access Point) 등의 역할을 수행하기 때문이다.

### NAT에 대해 설명해주세요?

NAT(Network Address Translation)은 라우터 또는 방화벽에서 IP 패킷의 포트 번호와 IP 주소를 다시 기록하는 기술이다. 패킷이 네트워크 외부로 나갈 때는 private IP를 public IP로 변환하고, 패킷이 네트워크 내부로 들어올 때는 public IP를 private IP로 변환하는 것이다. NAT의 주소 풀에 주소가 부족하면 패킷이 삭제되고 ICMP 메시지가 송신 호스트에게 발송된다.

### ICMP에 대해 설명해주세요?

ICMP(Internet Control Message Protocol)은 IP 패킷 전송에서 발생한 오류를 송신 호스트에게 전달하는 기능을 제공하는 프로토콜이다. 라우터에 의해 발생한다.

### IP와 IP 헤더에 대해 설명해주세요?

IP(Internet Protocol)은 네트워크 계층의 프로토콜로 인터넷에서 데이터를 주고받기 위해 사용한다. IP 헤더는 송수신 호스트의 IP 주소, 헤더 길이, 패킷 길이, TTL, 체크섬, 혼잡 제어에 사용하는 플래그 등을 포함한다.

### IPv4에 비교하여 IPv6를 설명해주세요?

첫번째, IP 주소가 32비트에서 128비트로 확장되었고 두번째, 헤더 구조가 단순화되었다. 예를 들어 이론상 패킷의 생존 시간 개념을 포함했던 IPv4 헤더의 TTL은 거치는 게이트웨이의 개수를 나타내는 IPv6 헤더의 Hop Limit으로 단순화되었다.

## 전송 계층

### TCP와 TCP 헤더에 대해 설명해주세요?

TCP는 전송 계층의 데이터 전송 프로토콜로, 연결형 서비스를 제공하여 데이터를 신뢰성을 보장한다. TCP 헤더는 20바이트로, 송수신 프로세스의 포트 번호, seq number, ack number, 체크섬, 윈도우 사이즈, 헤더의 크기, 각종 플래그들 등을 포함한다.

### TCP는 어떻게 신뢰성을 보장하는가?

첫번째, 3-way handshake로 연결을 설정한다. 두번째, seq number와 ack number로 패킷의 순서를 보장한다. 세번째, 오류 제어, 흐름 제어, 혼잡 제어를 제공한다.

### TCP 오류 제어에 대해 설명해주세요?

수신 프로세스는 데이터 전송 오류를 감지하면 응답을 하지 않으며, 송신 프로세스는 타임아웃 기능을 사용하여 패킷을 재전송한다.

### TCP Checksum에 대해 설명해주세요? (수신 프로세스는 어떻게 데이터 변형을 감지하나요?)

TCP Checksum은 TCP 헤더와 세그먼트, IP 헤더의 일부로 구성된 의사 IP 헤더를 대상으로 한다. 송신 프로세스는 의사 IP 헤더를 16비트 단위로 나누고 그 합을 구한 후, 합에 대하여 1의 보수를 취한 값을 TCP 헤더의 `Checksum` 필드에 넣는다. 수신 프로세스도 의사 IP 헤더로 체크섬을 구하고 수신받은 TCP 헤더의 `Checksum` 필드의 값과 더하여 모든 자릿수가 1이면 변형되지 않았음을 인지한다.

> 1의 보수를 구하는 방법: 1을 0으로, 0을 1로 바꾼다. NOT 연산하는 것과 같다.

### 혼잡과 TCP/IP 혼잡 제어에 대해 설명해주세요?

혼잡은 네트워크가 처리할 수 있는 패킷보다 많은 패킷이 입력되어 전체 네트워크의 성능이 저하되는 현상이다. TCP/IP 혼잡 제어 과정은 다음과 같다. 첫번째, 라우터는 출력 선도의 사용도가 한계치를 초과하면 주의 표시를 한다. 두번째, 패킷이 주의 표시된 출력 선로로 라우팅되는 경우 라우터는 IP 헤더의 `ECN` 플래그를 `CE`로 설정하여 패킷을 전송한다. 세번째, 수신 프로세스는 TCP 헤더의 `ECE` 플래그를 설정하여 송신 프로세스에게 패킷을 전송한다. 네번째, 송신 프로세스는 TCP 헤더의 `CWR` 플래그를 설정하여 전송 윈도우의 크기를 줄였음을 수신 프로세스에게 통지한다.

> 수신 프로세스가 혼잡의 발생을 중개하는 이유는 라우터가 네트워크 계층의 장비로 전송 계층의 TCP 프로토콜을 지원하지 않기 때문이다.

### 3-way handshake에 대해 설명해주세요?

TCP 프로토콜에서 클라이언트와 서버가 데이터를 주고받기 전 연결을 설정하는 과정이다. 최초에 클라이언트가 서버에게 연결을 요청하는 `SYN` 패킷을 보낸다. 서버는 클라이언트에게 연결을 허가하는 `ACK(SYN)` 패킷을 보낸다. 클라이언트는 서버에게 연결을 허가하는 패킷을 받았다는 `ACK` 패킷을 보낸다.

### 왜 3-way handshake를 사용하여 연결을 설정할까?

TCP는 양방향 통신을 지원하므로, 서버와 클라이언트는 서로 메시지를 주고받을 수 있어야한다. 따라서 서로의 메시지를 잘 주고 받는지 확인하기 위해 최소 3개의 메시지가 필요하다(서버가 클라이언트의 `SYN` 패킷에 대한 응답으로 `ACK` 패킷을 보낼 때 `SYN` 패킷을 피기배킹한다).

### 왜 최초로 연결 설정을 위해 `SYN` 패킷을 보낼 때 ISN을 난수로 생성할까?

ISN(initial sequence number)을 increment하게 증가시킨다고 하면 예측 가능한 seq number는 보안 문제도 있을 것이고, 이전 연결과 구분하기도 어려울 것이다. 예를 들어 클라이언트 A가 서버와 연결한 후 패킷 전송이 지연되어 도착 전 서버와 연결 해제되었다고 하자. 이때 클라이언트 B가 A와 동일한 포트로 서버와 연결한 후 지연된 패킷이 서버에게 도착해도 서버는 A와 B를 구분할 수 없어 B가 요구하지 않은 패킷을 A에게 응답할 것이다. 하지만 최초로 seq number를 생성할 때 난수를 사용하면 서버는 A와 B의 ISN을 비교하여 서로 다른 연결이라는 것을 알 수 있을 것이다.

### 4-way handshake에 대해 설명해주세요?

TCP 프로토콜에서 클라이언트와 서버가 연결을 해제하는 과정이다. 최초에 클라이언트가 서버에게 연결 해제를 요청하는 `FIN` 패킷을 보낸다. 서버는 클라이언트에게 연결 해제를 승인하는 `ACK` 패킷을 보낸다. 서버가 클라이언트에게 연결을 해제하는 `FIN` 패킷을 보낼 때까지 클라이언트는 서버로부터 데이터를 받을 수 있다. 클라이언트는 서버에게 연결 해제를 최종적으로 승인하는 `ACK` 패킷을 보낸다.

### 왜 연결 해제에 3-way handshake가 아니라 4-way handshake를 사용하는가?

클라이언트가 연결 해제를 요청하는 `SYN` 패킷을 보내고 서버가 응답하는 `ACK`와 연결 해제에 긍정하는 `FIN`을 함께 보낸다면 서버가 앞서 보낸 패킷이 분실될 수 있다. 또한 서버가 아직 보낼 패킷이 남았을 수도 있다.

### UDP와 UDP 헤더에 대해 설명해주세요?

UDP는 전송 계층의 데이터 전송 프로토콜로 비연결형 서비스를 제공하여 데이터의 신뢰성이 떨어진다. UDP 헤더는 8바이트로 송수신 프로세스의 포트 번호, 데이터그램의 크기, 체크섬을 포함한다.

### UDP가 데이터그램을 전송하는 방식에 대해 설명해주세요?

UDP는 Best effort 전달 방식을 지원한다. 이는 목적지까지 도착할 수 있도록 최선을 다하나 목적지에 도착하는 것은 보장하지 않는 방식을 의미한다. 또한 흐름 제어 기능 등을 제공하지 않아 데이터그램 분실이나 도착 순서가 변경되는 오류가 발생할 수 있다. 이러한 오류를 해결하려면 응용 계층의 프로세스가 내부적으로 기능을 구현해야한다.

### TCP와 UDP의 차이에 대해 설명해주세요?

첫번째, TCP는 연결 지향이고 UDP는 그렇지 않다. 두번째, TCP는 신뢰성을 보장하기 위해 여러 기능을 제공하지만 UDP는 그렇지 않다. 세번째, 그래서 UDP는 TCP보다 헤더 구조가 단순하고 데이터 처리가 더 빠르다.

### TCP는 언제 사용하고 UDP는 언제 사용할까요?

TCP는 데이터의 신뢰성을 보장해야하는 경우, UDP는 패킷 손실에 둔감하고 데이터 전송 시간이나 실시간성에 예민한 멀티미디어 응용 환경(스트리밍)에 사용한다.

### UDP가 어떻게 신뢰성 있는 데이터를 보장할 수 있을까?

데이터그램에 시퀀스 번호를 정의하고 서버와 클라이언트가 데이터 전송 오류 발생 시 어떻게 할 것인지 상호 정의하면 되겠다.

## HTTP

### HTTP에 대해 설명해주세요?

HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층의 프로토콜로 웹 상에서 서버와 클라이언트가 하이퍼텍스트 형식의 데이터를 주고받을 때 사용한다.

>  하이퍼텍스트(Hypertext)는 다른 텍스트나 컨텐츠에 대한 참조를 포함할 수 있는 텍스트이다. 

### HTTP의 비연결성과 무상태성에 대해 설명해주세요? (HTTP의 특징에 대해 설명해주세요?)

`HTTP의 무상태성`은 각각의 HTTP 요청은 독립적이어서 서버가 이전 요청에 대한 어떠한 상태도 유지하지 않는 것을 말한다. `HTTP의 비연결성`은 서버가 클라이언트에게 응답을 보낸 후 연결을 끊는 것을 말한다.

### HTTP 메시지는 어떻게 이루어져있나요? 

HTTP 메시지는 크게 헤드와 본문으로 구성된다. 본문에는 서버와 클라이언트가 서로 주고받고자 하는 페이로드가 들어간다. 헤드는 요청문 혹은 응답문과 헤더들로 나뉜다. 헤더는 부가적인 정보가 들어간다. 요청문은 HTTP 메서드, URI, HTTP 버전을 명시하고 응답문은 HTTP 버전, HTTP 상태 코드, HTTP 상태 텍스트를 명시한다.

### HTTP 메서드에 대해 설명해주세요?

HTTP 메서드는 서버가 무엇을 해야할지 명시한 것이다. `GET`, `POST`, `DELETE`, `PUT`, `PATCH`, `OPTIONS` 등이 있다.

### `GET`과 `POST`의 차이에 대해 설명해주세요?

첫번째, `GET`은 서버에 자원을 요청할 때, `POST`는 서버에 자원을 생성할 때 사용한다. 두번째, `GET`은 안전한 메서드로 멱등하나 `POST`는 멱등하지 않다. 세번째, `GET`은 서버에 데이터를 전달하기 위해 URL을 사용하여 보안이 약하지만 `POST`는 본문을 사용한다.

### `PUT`과 `PATCH`의 차이에 대해 설명해주세요?

`PUT`은 자원을 교체할 때 사용하고 `PATCH`는 자원의 일부를 수정할 때 사용한다.

### HTTP 상태 코드에 대해 설명해주세요?

`200`번대는 클라이언트의 요청이 성공적으로 처리되었음을 나타낸다. `300`번대의 응답은 리다이렉트해야하는 경우를 나타낸다. `400`번대의 응답은 클라이언트 요청 메시지에 오류가 있음을 나타낸다. 예를 들어 `401 Unauthorized`는 요청한 자원에 접근할 수 있는 권한이 없는 경우를, `404 Not Found`는 요청한 자원을 찾을 수 없는 경우를 나타낸다. `500`번대의 응답은 요청을 수행하는 과정에서 서버에 내부적으로 오류가 있음을 나타낸다.

### HTTP 헤더에서 캐시와 관련된 헤더에는 무엇이 있나요?

`Cache-Control`, `Expires`, `Age`, `ETag`, `If-None-Match`가 있다.

- `Cache-Control`(응답): 서버와 클라이언트가 캐싱 메커니즘을 정하기 위해 사용한다.
- `Expires`: (응답) 캐싱된 리소스가 만료되는 날짜를 나타낸다. (`max-age`나 `s-maxage` directive를 가진 `Cache-Control` 헤더가 응답에 포함되면 `Expires`는 무시된다)
- `Age`: (응답) 리소스가 캐시된 후 경과 시간을 초 단위로 나타낸다.
- `ETag`:  (응답) 리소스의 식별자나 버전을 나타낸다.
- `If-None-Match`: (요청) 캐싱된 리소스의 ETag 값이다. 클라이언트는 다음 요청에서 이 헤더를 포함하고, 서버는 리소스의 현재 ETag 값과 비교하여 변경이 없다면 `304 Not Modified`를 반환하고 변경이 있다면 새로운 리소스를 보내준다.

### HTTP `Cache-Control` 헤더에 대해 설명해주세요?

`Cache-Control` 헤더는 HTTP 응답에서 캐싱 메커니즘을 정하기 위해 사용한다.

- `no-store`: 캐싱하지 않는다.
- `no-cache`: 클라이언트는 캐싱된 리소스를 사용하기 전 서버에 재검증을 요청해야한다.
- `public`: 리소스가 public 캐시(중간 프록시 서버 등)에 캐싱될 수 있다.
- `private`: 리소스가 public 캐시에 캐싱될 수 없고 특정 사용자에게만 제공된다.
- `max-age=<seconds>`: 캐싱된 리소스가 유효한 시간(초)를 설정한다. 이 시간이 경과하면 클라이언트는 서버에 재검증을 요청한다.
- `s-maxage`: public 캐시에서 리소스가 유효한 시간(초)를 설정한다. private 캐시에는 적용되지 않는다.

### 다음 HTTP 헤더에 대해 설명해주세요?

- `Accept`: (요청) 클라이언트가 서버에게 원하는 미디어 타입이다.
- `User-Agent`: (요청) 클라이언트의 사용자 에이전트(브라우저 또는 애플리케이션)에 대한 정보이다.
- `Authorization`: (요청) 클라이언트가 서버에게 인증 정보를 제공하기 위해 사용한다.
- `Referer`: (요청) 현재 요청이 발생한 페이지나 리소스의 URL을 나타낸다. (예: https://www.example.com/index.html)
- `Origin`: (요청) 현재 요청이 시작된 origin을 나타낸다. (예: https://www.example.com:443)
- `Content-Type`: 요청 또는 응답에 포함된 컨텐츠의 타입을 정한다. 주로 MIME 유형을 사용하여 텍스트, 이미지, 동영상 등을 지정한다.
- `Location`: (응답) 리다이렉션 응답에서 사용되며, 클라이언트에게 리다이렉션된 리소스의 위치를 알려준다.
- `Set-Cookie`: (응답) 서버가 클라이언트의 쿠키 값을 설정하기 위해 사용한다.

### HTTP `Set-Cookie`에 대해 설명해주세요?

![url](https://user-images.githubusercontent.com/57662010/211197277-083bc783-b79f-4239-99d0-a00c39ab09b7.png)

HTTP `Set-Cookie`는 서버가 클라이언트에게 쿠키 값을 설정하기 위해 사용한다.

- `Expires`: 쿠키가 만료되는 날짜이다.
- `Max-Age`: 쿠키가 유효한 시간이다. `Expires`는 무시된다.
- `Secure`: HTTPS를 사용한 요청에만 전송된다.
- `HttpOnly`: 자바스크립트 접근을 막는다. XSS를 방지할 수 있다.
- `Domain`: 도메인 이름이 일치하는 요청에만 전송된다.
- `Path`: path가 일치하는 요청에만 전송된다.

### HTTP/1.0과 HTTP/1.1의 차이에 대해 설명해주세요?

첫번째, HTTP 1.0은 기본적으로 매 요청마다 커넥션을 생성하고 해제하지만(persistent connection을 사용하려면 `Connection: Keep-Alive`와 `Keep-Alive` 헤더를 지정해야한다) HTTP/1.1은 기본적으로 persistent connection을 지원한다. 두번째, HTTP/1.1은 파이프라이닝을 사용하여 요청에 대한 응답을 기다리지 않고 다음 요청을 보내 지연을 줄일 수 있다.

### HTTP 1.0의 단점은 어떻게 해결할 수 있을까? 

이미지 스프라이트, 번들링, 이미지를 base64로 인코딩하는 등의 기법을 사용해 요청의 개수를 줄여볼 수 있다.

### HTTP/1.1의 문제에 대해 알려주세요?

첫번째, 기본적으로 신뢰성을 보장하는 TCP를 사용하므로, 앞 선 패킷의 처리가 완료될 때까지 뒤이은 패킷의 처리가 대기하는 HOL(Head of Line) Blocking 문제가 발생한다. 두번째, persistent connection에서 요청의 헤더가 중복되는 경우가 많아 대역폭이 낭비되는 문제가 발생한다.

### HTTP/2.0에 대해 설명해주세요?

첫번째, 멀티플렉싱(한 개의 TCP 커넥션에서 여러 개의 스트림을 병렬로 유지한다. 각 스트림은 한 쌍의 HTTP 요청과 응답을 처리한다)을 지원한다. 두번째, 헤더를 압축하여 메시지의 크기를 줄인다(바이너리 프레이밍 계층에서 HTTP/1.1 헤더 프레임과 데이터 프레임으로 분할하고 각각 바이너리 인코딩하여 HTTP/2.0 메시지로 만든다). 세번째, 클라이언트의 요청 없이 리소스를 전송하는 서버 푸쉬를 지원한다. 예를 들어 클라이언트가 HTML 문서를 요청하면 서버는 문서를 분석하여 필요한 리소스(스타일 시트, 스크립트, 이미지 등)을 푸쉬한다.

### HTTP/2.0 헤더 압축에서 사용되는 알고리즘에 대해 설명해주세요?

HTTP/2.0 헤더 압축은 HAPCK(Header Compression for HTTP/2) 알고리즘을 사용한다. 구체적으로는 static table과 dynamic table을 유지해 중복되는 헤더는 테이블의 인덱스를 전송하고 중복되지 않은 헤더는 Huffman 인코딩 처리한다.

### HTTP/3.0에 대해 설명해주세요?

UDP에 기반한 QUIC 프로토콜을 사용하는데, 헤더를 커스텀하여 TCP만큼의 신뢰성을 보장하며 연결 설정에 필요한 데이터를 응답과 함께 보내 연결 과정을 축소한다. 기본적으로 TLS를 적용한다. 이전에는 TCP handshake, TLS handshake, Data transfer 까지 3RTT가 걸렸다면 현재는 QUIC handshake, Data transfer로 1RTT가 걸린다.

> RTT는 Route Trip Time의 약어로, 네트워크 통신에서는 지연 시간을 나타내는 데 사용한다. 1RTT는 송신측이 패킷을 전송한 후부터, 수신측이 패킷에 대한 응답을 보내고 송신측이 이 응답을 수신받기까지의 시간이다.

> 참고
>
> - [HTTP/3는 왜 UDP를 선택한 것일까?](https://evan-moon.github.io/2019/10/08/what-is-http3/)

## HTTPS

### HTTPS에 대해 설명해주세요?

HTTPS는 HTTP를 암호화한 버전으로 SSL(TSL) 프로토콜을 사용한다. 서버와 클라이언트는 TLS handshake 과정을 통해 세션 키를 분배하고 해당 세션 키로 HTTP 메시지를 암호화하여 통신한다.

> 어떤 암호화 알고리즘을 사용하는가? [참고](https://aws-hyoh.tistory.com/47)

### SSL 프로토콜에 대해 설명해주세요?

SSL 통신은 SSL 디지털 인증서를 사용하여 서버의 공개 키가 변조되지 않았음을 보장한다. SSL 디지털 인증서는 엄격하게 공인된 CA(Certificate Authority)가 발급한다. 첫번째, 서버는 비밀 키와 공개 키를 생성하고 CA에게 공개 키를 보내어 디지털 인증서 발급을 요청한다. 두번째, CA는 CA의 정보(디지털 서명 등의 서비스 정보)와 서버의 정보(이름, 공개 키)로 디지털 인증서를 만들고, CA의 비밀 키로 암호화하여 서버에게 디지털 인증서를 발급한다. 세번째, 서버는 클라이언트에게 디지털 인증서를 전송한다. 네번째, 클라이언트는 내장하고 있는 CA와 CA의 공개 키 리스트를 사용하여 디지털 인증서를 복호화하고 서버의 공개 키를 얻는다.

### SSL 프로토콜은 왜 대칭 키와 공개 키 방식을 혼합하여 사용하나요?

대칭 키는 단순하지만 분배 과정에 키가 탈취당할 수 있다. 공개 키는 안전하지만 비밀 키로 복호화하는 연산이 매우 크다. 따라서 각자의 장점만 취하기 위해 키 분배는 공개 키 방식을 사용하고 데이터 송수신에서는 대칭 키 방식을 사용한다.

### HTTPS 동작 과정에 대해 설명해주세요?

TCP 3-way handshake, TLS handshake, HTTP Request, TLS 세션 해제, TCP 4-way handshake

### TLS handshake에 대해 설명해주세요?

 `ClientHello`(클라이언트가 서버에게 클라이언트의 랜덤 데이터, 지원하는 암호화 방식 등을 전송한다), `ServerHello`(서버가 클라이언트에게 서버의 랜덤 데이터, 선택한 암호화 방식, 인증서를 전송한다), `Key Exchange`(클라이언트는 CA의 공개 키로 인증서를 복호화하여 서버의 공개 키를 얻는다. 서버와 클라이언트의 랜덤 데이터를 조합하여 세션 키를 만들고 서버의 공개 키로 암호화하여 서버에게 전송한다. 서버는 자신의 비밀 키로 해당 값을 복호화하여 세션 키를 얻는다. 이들은 앞으로 세션 키를 사용하여 데이터를 암호화해 통신할 것이다.), `Finished`(TLS handshake를 완료한다)

### TLS 연결 해제에 대해 설명해주세요?

연결 해제를 원하는 호스트에서 `Close Notify` 메시지를 전송하여 종료를 요청하고, 수신 호스트가 이에 응답한다.

### 실시간 통신을 구현할 때 어떤 기술을 사용할 수 있는가?

실시간 통신을 구현하기 위하여 HTTP 기반의 폴링과 롱 폴링, TCP/IP Socket, HTML5 WebSocket, HTML5 SSE을 사용할 수 있다.

### 폴링과 롱 폴링에 대해 설명해주세요?

폴링과 롱 폴링은 HTTP를 기반으로 실시간 단방향 통신을 구현하는데 사용한다. 폴링(polling)은 클라이언트가 서버에게 주기적으로 HTTP 요청을 보내는 것이다. 폴링의 주기가 짧으면 서버에 부하가 갈 수 있으나 주기가 길면 실시간성이 떨어진다. 롱 폴링(long polling)은 서버가 클라이언트에 즉시 응답을 보내지 않고 대기하다가 이벤트가 발생하면 응답한다. 클라이언트는 응답을 받으면 즉시 다시 요청한다. 클라이언트의 수가 많거나 이벤트의 발생이 잦다면 서버에 부하가 생길 수 있다.

### TCP/IP Socket과 HTML5 WebSocket, HTML5 SSE의 차이에 대해 설명해주세요?

모두 실시간 통신을 구현하는데 사용되나 차이점은 다음과 같다. TCP/IP Socket은 TCP/IP 기반의 양방향 네트워크 통신을 구현하는데 사용되는 커널 내부 인터페이스이다. HTML5 WebSocket은 HTTP와 TCP를 기반으로 웹 브라우저와 웹 서버 간의 양방향 네트워크 통신을 구현하는데 사용되는 프로토콜이다. HTML5 SSE(Server Sent Event)는 HTTP를 기반으로 서버가 클라이언트에게 단방향으로 실시간 이벤트 스트림을 전송하는 데 사용한다. 클라이언트는 이벤트 스트림을 구독하여 이벤트가 발생할 때마다 서버로부터 데이터를 받을 수 있다.

### HTTP/1.1부터 지속 커넥션을 기본적으로 지원하고 있는데, 왜 WebSocket 프로토콜이 필요한 걸까?

HTTP는 클라이언트가 서버로의 단방향 통신 방식을 사용한다. 즉, 클라이언트가 요청을 보내야지만 서버는 메시지(응답)을 보낼 수 있다 WebSocket은 서버와 클라이언트 간의 양방향 통신을 제공한다.

## DNS

### DNS에 대해 설명해주세요?

DNS(Domain Name System)은 도메인 이름을 IP 주소로 변환하기 위해 사용하는 분산 데이터베이스 시스템이다. 도메인 이름과 IP 주소를 저장한 DNS 서버가 계층적으로 구성되어있다.

### DNS 프로토콜 동작 과정을 설명해주세요? (도메인 이름을 IP 주소로 변환하는 과정을 알려주세요?)

예를 들어 사용자가 주소창에 `www.example.com`을 검색했다고 하자. (1) 브라우저는 브라우저 캐시, 로컬 호스트 파일, DNS 캐시 테이블 순으로 도메인 이름을 조회한다. (2) 없으면 DNS Resolver를 호출하여 변환을 요청한다. (3) DNS Resolver는 DNS 프로토콜을 사용하여 로컬 DNS 서버에 질의한다. (4) 로컬 DNS는 캐시를 조회한 후 없다면 루트 DNS 서버에 질의한다. 루트 DNS 서버(`.`)는 캐시를 조회한 후 없다면 TLD DNS 서버의 IP 주소를 응답한다. 로컬 DNS 서버는 TLD DNS 서버에 질의한다. TLD DNS 서버(`.com`)은 캐시를 조회한 후 없다면 Second Level Domain DNS 서버의 IP 주소를 응답한다. 로컬 DNS 서버는 Second Level Domain DNS 서버에 질의한다. Second Level Domain DNS 서버(`.example.com`)가 자신의 IP 주소를 응답한다. (5) 로컬 DNS 서버는 이 IP 주소를 캐싱하고 DNS Resolver에 응답한다. (5) DNS Resolver는 IP 주소를 DNS 캐시 테이블에 캐싱하고 브라우저에게 응답한다.

> ISP(Internet Service Provider)의 DNS 서버는 로컬 DNS 서버의 대체 혹은 보조 수단으로 사용된다.

## 인증과 인가

### 인증과 인가의 차이는 무엇인가?

인증은 사용자가 제출한 정보로 사용자가 누구인지 확인하는 절차이며, 인가는 인증된 사용자가 서버가 제공하는 자원이나 기능에 접근하기 위한 권한을 부여하는 것이다.

### JWT에 대해 알려주세요?

JWT(JSON Web Token)은 JSON 형식의 헤더와 페이로드를 각각 base64 인코딩한 문자열과 서명이 `.`로 구분되어있다. 서버의 부하를 줄이고 HTTP의 무상태성을 유지하기 위해 사용하는 토큰 인증 방식에서 사용한다.

### OAuth 2.0에 대해 설명해주세요?

OAuth(Open Authorization) 2.0은 인증에 사용하는 표준 프로토콜이다. 클라이언트는 사용자를 대신하여 인증 서버에게 액세스 토큰을 발급받아 리소스 서버에게 자원을 요청한다.

### OAuth 2.0에서 id 토큰과 액세스 토큰에 대해 설명해주세요?

id 토큰은 인증 서버에게 액세스 토큰을 요청할 때 사용하고, 액세스 토큰은 리소스 서버에게 리소스를 요청할 때 사용한다.

### OAuth가 어떤 식으로 동작하는지 설명해주세요?

첫번째, 사용자가 "플랫폼으로 로그인하기"를 누르면 클라이언트는 해당 플랫폼의 로그인 페이지를 띄워준다. 두번째, 사용자가 로그인을 완료하면 클라이언트는 플랫폼에 등록한 Redirect URL로 리다이렉트되며, 해당 url에 id 토큰이 담겨 온다. 세번째, 클라이언트는 Redirect URL에서 파싱한 id 토큰을 가지고 인증 서버에게 액세스 토큰을 요청한다. 네번째, 클라이언트는 인증 서버로부터 액세스 토큰을 발급받으면 사용자를 원래의 컨텍스트으로 돌려보내주고 앞으로는 액세스 토큰을 사용해서 클라이언트를 대신하여 플랫폼의 리소스 서버에게 요청을 보낸다.

### 토큰 인증 방식의 경우 토큰을 어디에 실어보내나요?

`Authorization` 헤더나 `Cookie` 헤더에 보낸다.

### CSRF와 XSS에 대해 알려주세요?

모두 웹 보안 공격의 일종이다. CSRF(Cross Site Request Forgery)는 사용자의 권한을 사용해 사용자가 의도하지 않은 악의적인 요청을 보내도록 하는 공격이다. XSS(Cross-Site Scripting)은 웹 페이지에 악성 스크립트를 삽입하여 사용자의 브라우저에서 실행되는 공격이다.

## 기타

### 웹 서버와 WAS의 차이에 대해 설명해주세요?

웹 서버는 클라이언트의 요청에 따라 정적 파일을 반환하며, WAS(Web Application Server)는 데이터베이스에 접속하거나 비지니스 로직을 처리하여 동적 컨텐츠를 생성해 반환한다.

### URI과 URL의 차이에 대해 알려주세요?

URI(Uniform Resource Identifier)는 네트워크 상에서 자원을 고유하게 식별한다. URL(Uniform Resource Location)은 URI의 일종으로, 네트워크 상에서 자원의 위치를 식별한다. URL이 URI에 속하는 개념이라고 볼 수 있다.

### 웹사이트 URL은 왜 `www`로 시작할까요?

인터넷 초기에는 웹 사이트가 주로 웹 서버에서 호스팅되고 있었으므로 이를 나타내기 위해 `www`라는 서브도메인을 사용했다. 현재는 웹 사이트가 반드시 웹 서버를 통해서만 호스팅되는 것이 아니므로 생략할 수 있다.

> WWW는 World Wide Web의 약어로, 인터넷에서 웹 서버에 접속하기 위한 프로토콜을 나타낸다. 

### API란 무엇인가?

API(Application Programming Interface)는 애플리케이션이 상호작용할 수 있도록 정의한 규칙의 집합이다. 웹 개발에서는 브라우저가 제공하는 기능의 집합이나 웹 서버가 HTTP 통신을 통해 웹 클라이언트에게 제공하는 기능의 집합으로 볼 수 있다.

### REST API(Restful API)란 무엇인가?

REST 규칙을 준수한 API를 말한다. 필요한 자원을 URI로 표현하고 자원에 대한 행위를 HTTP 메서드로 표현한다. CREATE는 POST, READ는 GET, UPDATE는 PATCH와 PUT, DELETE는 DELETE를 사용한다.

### REST API의 장단점을 설명해주세요?

HTTP 통신이 기본적으로 제공하는 기능을 사용하므로 추가적인 설정을 필요로 하지 않는다. 하지만 표준이 아니므로 개발자에 따라 다르게 작성될 수 있다.

### 로드 밸런싱에 대해 설명해주세요?

로드 밸런싱은 서버를 수평적 확장하여 트래픽을 분산해 부하를 줄이는 것이다. 서버가 다운돼도 다른 인스턴스가 서비스를 제공하는 무중단 배포가 가능하다.

### L4 로드밸런싱과 L7 로드밸런싱에 대해 설명해주세요?

L4 로드밸런싱은 전송 계층에서 동작하는 하드웨어 로드 밸런서이다. L4 로드 밸런서는 패킷을 분석하여 IP 주소와 포트 번호를 기반으로 트래픽을 분산한다. L7 로드밸런싱은 애플리케이션 계층에서 동작한다. L7 로드 밸런서는 HTTP 헤더, URL 경로, query parameter, path 등을 분석하여 트래픽을 분산한다. L4는 L7에 비해 빠르고 비용이 저렴하지만 L7은 더 세심한 분산을 제공할 수 있다. Ngnix, Amazon ELB(Elastic Load Balancer) 등이 있다.

### 프록시와 리버스 프록시에 대해 설명해주세요?

프록시는 클라이언트와 서버 사이에 위치하여 통신을 중개하는 호스트이다. Forward Proxy는 클라이언트를 대신하여 서버와 직접적으로 통신한다. 방화벽을 통해 클라이언트를 악성 공격으로부터 보호할 수 있고, IP 주소와 같은 정보를 숨겨 익명성을 보장할 수 있다. 또한 응답을 캐싱하여 응답 시간을 줄이고 대역폭을 절약할 수 있다. Reverse Proxy는 서버를 대신하여 클라이언트와 직접적으로 통신한다. Forward Proxy와 비슷한 장점을 서버에게 제공하며, 로드밸런싱을 제공할 수 있다.

### CDN에 대해 설명해주세요?

CDN(Content Delivery Network)는 대개 정적 에셋을 빠르게 전달하기 위해 사용하는 네트워크이다. 분산 서버(캐시 서버, Edge 서버)들이 데이터의 복사본을 저장하여, 사용자와 가장 가까운 서버가 데이터 요청을 처리한다.
