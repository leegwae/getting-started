# database

## TOC

- [데이터베이스 키](#데이터베이스-키)
- [무결성 제약조건](#무결성-제약조건)
- [SQL Injection](#SQL-Injection)
- [SQL과 NoSQL](#SQL과-NoSQL)
- [서버 확장](#서버-확장)
- [정규화](#정규화)
- [트랜잭션](#트랜잭션)
- [트랜잭션 격리 수준](#트랜잭션-격리-수준)
- [MVCC](#MVCC)
- [SQL 문법](#SQL-문법)

## 데이터베이스 키

### 키가 무엇이고 어떤 종류가 있나요?

키는 릴레이션 내에서 튜플을 고유하게 식별하는 속성의 집합이다. 슈퍼키, 기본 키, 후보 키, 대체 키, 외래 키가 있다.

### 각각의 키에 대해 설명하라

슈퍼 키는 튜플을 고유하게 식별하는 속성의 집합이다. 후보 키는 튜플을 고유하게 식별하기 위한 최소한의 속성의 집합이다. 기본 키는 후보 키 중에서 관리자에 의해 선택된 키이다. 대체 키는 기본 키가 아닌 후보 키이다. 외래 키는 다른 릴레이션이나 자체 릴레이션의 기본 키를 참조하는 키이다.

### 키의 유일성과 최소성에 대해 설명하라

`키의 유일성`은 키가 튜플을 고유하게 식별할 수 있는 특징을 말한다. `키의 최소성`은 키가 튜플을 고유하게 식별하기 위해 필요한 최소한의 속성으로 구성되어있는 특징을 말한다.

### 기본 키로 지정한 속성과 UNIQUE로 지정한 속성은 어떤 차이가 있을까?

첫번째, 기본 키로 지정한 속성은 튜플을 고유하게 식별하기 위해 사용하나 UNIQUE로 지정한 속성은 속성 값의 중복을 방지하기 위해 사용한다. 두번째, 기본 키로 지정한 속성은 튜플마다 한 개만 가질 수 있지만 UNIQUE는 여러 개가 존재할 수 있다. 세번째, 기본 키는 null 값을 허용하지 않지만 UNIQUE는 허용한다.

## 무결성 제약조건

### 무결성 제약조건이란 무엇인가요?

무결성 제약조건은 데이터베이스가 일관성 있는 상태를 유지하기 위해 정의한 규칙들이다.

### 무결성 제약조건의 종류에 대해 설명해주세요?

도메인 제약조건은 각 속성 값이 원자값이어야한다는 제약조건이다. 키 제약조건은 키로 지정된 속성의 값에 중복이 없어야한다는 제약조건이다. 엔티티 무결성 제약조건은 기본 키를 구성하는 속성은 널 값을 가질 수 없다는 제약조건이다. 참조 무결성 제약조건은 외래 키의 값이 참조하는 릴레이션의 기본 키이거나 null 값이어야한다는 제약조건이다.

### DBMS는 무결성 제약조건을 만족시키기 위해 어떤 옵션을 제공하나요?

제한은 제약조건의 위배를 야기하는 연산을 거절한다. 연쇄는 튜플을 삭제하면 해당 튜플을 참조하는 튜플도 삭제한다. 널값은 튜플을 삭제하면 해당 튜플을 참조하는 튜플의 외래 키에 null을 삽입한다. 디폴트값은 튜플을 삭제하면 해당 튜플을 삭제하는 외래 키에 디폴트값을 삽입한다.

## SQL Injection

> 참고
>
> - https://noirstar.tistory.com/264
> - https://www.bugbountyclub.com/pentestgym/view/53

### SQL Injection이 무엇인가요?

SQL Injection은 악의적인 SQL문을 실행해서 데이터베이스를 비정상적으로 조작하는 공격 방법이다.

### SQL Injection의 종류에 대해 설명해주세요?

Error based Injection은 데이터베이스의 오류 메시지로 정보를 얻는다. Union based Injection은 SQL문에 `UNION`절을 삽입하여 정보를 얻는다. Blind SQL Injection은 데이터베이스로부터 참과 거짓만 알 수 있는 경우 이를 이용해 정보를 얻는다.

### SQL Injection은 어떻게 대응할 수 있을까요?

첫번째, 사용자의 입력값을 검증한다. 두번째, SQL 서버에 오류가 발생했을 때 오류 메시지를 노출하지 않도록 한다. 세번째, 미리 컴파일된 SQL문을 사용하여 사용자의 입력을 단순 문자열로 인식하게 한다.

## SQL과 NoSQL

### SQL이 무엇이고 SQL DB의 장단점이 무엇인지 설명해주세요?

SQL은 관계형 데이터베이스에 데이터를 저장하고 처리하기 위한 프로그래밍 언어이다.

SQL의 장점은 첫번째, 스키마가 명확하게 정의되어있어 데이터의 무결성을 보장할 수 있다. 두번째, 관계를 생성하에 데이터를 중복없이 저장할 수 있다. SQL의 단점은 첫번째, 스키마가 유연하지 못하여 수정하기 힘들다. 두번째, 관계 때문에 조인이 복잡해질 수 있다. 세번째, 수평적 확장이 어렵다.

### SQL DB는 언제 사용하실 건가요?

첫번째 ACID 원칙을 준수해야하거나 두번째, 데이터의 구조를 명확히 정의해야하는 경우 사용할 것이다.

### NoSQL이 무엇이고 NoSQL DB의 장단점이 무엇인지 설명해주세요?

NoSQL은 비관계형 데이터베이스에 데이터를 저장하고 처리하기 위한 프로그래밍 언어이다. 도큐먼트, 키-값, 그래프 데이터베이스가 있다.

NoSQL의 장점은 첫번째, 데이터의 구조를 변경하기 쉽다. 두번째, 조인을 하지 않으므로 데이터를 읽는 속도가 빠르다. 세번째, 스케일 아웃이 용이하다. NoSQL의 단점은 첫번째, 데이터의 구조가 명확하거나 일관적이지 않다. 두번째, 데이터의 중복을 허용하므로 수정과 삭제가 어렵다.

### NoSQL DB는 언제 사용하실 건가요?

첫번째 데이터의 구조가 명확하지 않거나 대용량의 데이터를 저장하는 경우, 두번째 읽기는 자주 발생하지만 쓰기와 삭제는 자주 일어나지 않는 경우 이용할 것이다.

### Soft Delete를 사용했을 때의 단점은 무엇인가요?

첫번째, Hard Delete를 했을 때보다 더 많은 용량을 필요로 한다. 두번째, 데이터를 읽을 때 분기 처리를 해주어야한다.

## 서버 확장

### 서버를 확장하는 방법에 대해 설명해주세요?

서버를 확장하는 방법은 크게 Scale Up과 Scale Out이 있다. Scale Up은 하드웨어의 성능을 향상시키는 것이다. Scale Out은 데이터베이스 서버를 여러 대로 분산하는 것이다. 균등하게 부하를 분산하는 로드밸런싱을 요한다.

### Scale out하는 방법에 대해 설명해주세요?

Scale out하는 방법에는 샤딩, 복제, 클러스터링이 있다. 샤딩은 데이터를 분할하여 분산 저장하는 것이다. 복제는 데이터를 중복하여 분산 저장한다. 클러스터링은 여러 대의 서버가 하나의 데이터베이스 인스턴스를 공유하는 것이다.

## 정규화

### 정규화란 무엇인가요?

정규화는 데이터의 중복과 갱신 이상을 최소화하도록 데이터를 구조화하는 과정이다.

### 갱신 이상에는 무엇이 있나요?

갱신 이상에는 수정 이상, 삽입 이상, 삭제 이상이 있다. 수정 이상은 데이터 중복이 있어 수정 연산시 데이터 불일치가 발생하는 문제이다. 삽입 이상은 삽입 연산 시 불필요한 데이터까지 추가해야하는 문제이다. 삭제 이상은 삭제 연산 시 필요한 데이터까지 삭제되는 문제이다.

### 정규화 과정에 대해 말씀해주세요?

다양한 정규화 과정이 있는데 그중에서 제1정규형, 제2정규형, 제3정규형, BCNF에 대해 말하겠다. 제1정규화는 속성이 원자값을 가지도록 테이블을 분해하는 것이다. 제2정규화는 제1정규형을 만족하면서 기본 키에 대해 완전 함수적 종속성을 가지도록 테이블을 분해하는 것이다. 예를 들어 학생 릴레이션이 학번, 학과이름, 학과전화번호, 과목번호, 학점으로 이루어져있다고 하자. 기본 키는 학번과 과목번호이다. 이때 학과이름과 학과전화번호는 기본 키에 함수적으로 종속하나, 기본 키의 진부분집합인 학번에 함수적으로 종속한다. 즉, 부분 함수적 종속성이 릴레이션에 존재한다. 제3정규화는 제2정규형를 만족하면서 기본 키에 대한 이행적 함수적 종속성이 없도록 테이블을 분해하는 것이다. 예를 들어 학생 릴레이션이 학번, 학과이름, 학과전화번호로, 수강 릴레이션이 학번, 과목번호, 학점으로 이루어져있다고 하자. 기본 키는 각각 학번과 과목번호이다. 이때 학과이름은 학번에, 학과전화번호는 학과이름에 함수적으로 종속한다. 즉, 이행적 함수적 종속성이 존재한다. BCNF는 제3정규형을 만족하면서 모든 결정자가 후보 키가 되도록 테이블을 분해하는 것이다.

> - 결정자는 릴레이션에서 다른 속성을 고유하게 결정하는 하나 이상의 속성이다. 속성 A가 B의 결정자라면, 임의의 두 튜플에서 A 속성의 값이 같을 때 B 속성의 값도 같다.
> - 함수적 종속성: 속성 A가 B의 결정자라면, B는 A에 함수적으로 종속한다.
> - 완전 함수적 종속성: 속성 B가 속성 A에 함수적으로 종속하지만 A의 어떤 진부분집합에도 함수적으로 종속하지 않으면, B는 A에 완전 함수적으로 종속한다.
> - 부분 함수적 종속성: 속성 B가 속성 A에 함수적으로 종속하나 완전 함수적으로 종속하지 않으면, B는 A에 부분 함수적으로 종속한다.
> - 이행적 함수적 종속성: 속성 B가 속성 A에 함수적으로 종속하고 속성 C가 속성 A에 함수적으로 종속하면, 속성 C는 속성 A에 함수적으로 종속한다.

### 정규화의 단점은 무엇이고 어떻게 해결할 수 있나요?

일반적으로 읽기 연산이 갱신 연산보다 자주 일어나는데 정규화를 통해 릴레이션이 여러 개로 분할되면 조인 연산 비용이 발생한다. 이는 역정규화를 통해 의동적으로 비정규화된 릴레이션을 사용하여 조인 연산 비용을 줄여볼 수 있다.

## 인덱스

> 참고
>
> - [[DB] 10. B-Tree (B-트리)](https://rebro.kr/169)
> - [[DB] 11. 인덱스(Index) - (1) 개념, 장단점, B+Tree 등](https://rebro.kr/167)

### 인덱스란 무엇인가요?

인덱스는 특정 컬럼의 데이터를 정렬해서 튜플의 물리 주소와 함께 저장한 자료구조이다. 테이블에서 검색 속도를 높이기 위해 사용한다.

### 인덱스의 장점과 단점은 무엇인가요?

인덱스의 장점은 읽기가 상당히 빨라진다. 인덱스의 단점은 첫번째, 인덱스를 저장하기 위해 추가 공간을 필요로 한다. 두번째, 삽입, 삭제, 수정 연산의 경우 인덱스 테이블에도 반영해야하므로 연산 속도가 느려진다.

### 언제 인덱스를 사용해야하고 사용하지 말아야하나요?

첫번째 특정 컬럼을 `WHERE`, `JOIN`, `ORDER BY`에 자주 명시하는 경우, 두번째 카디날리티(릴레이션의 튜플의 수)가 높은 경우 해당 컬럼을 인덱스로 지정하는 것이 적절하다. 그러나 첫번째, 데이터의 중복이 많은 경우 두번째, 삽입, 수정, 삭제 연산이 자주 발생하는 경우 적절하지 않다.

### 인덱스는 수정, 삽입, 삭제 연산시 어떤 작업을 하나요?

삽입 연산 시 새로운 데이터에 대한 인덱스를 추가한다. 삭제 연산 시 인덱스를 사용하지 않는다고만 표시한다. 수정 연산 시 새로운 인덱스를 추가하고 기존 인덱스는 사용하지 않는다고 표시한다.

### 인덱스는 어떻게 구현하나요?

인덱스는 해시 테이블과 균형 트리의 일종인 B-Tree, B+Tree를 사용할 수 있다. `해시 테이블`은 키에 컬럼의 값을, value에 물리 주소를 저장한다. 상수 시간에 접근할 수 있어 검색이 매우 빠르다. 등호 연산에는 최적화되어있지만 컬럼의 값이 정렬되어있지 않으므로 부등호 연산에는 적합하지 않다. B-Tree와 B+Tree는 단말 노드가 모두 같은 레벨로 유지되어 `O(logn)`의 탐색 시간을 보장하며 키가 정렬되어 있어 부등호 연산에 적합하다.

### B-Tree와 B+Tree에 대해 설명해주세요?

B-Tree는 균형 트리의 일종으로 노드가 포인터와 데이터를 저장한다. B-Tree의 노드는 키의 개수가 k개이면 자식 노드의 개수는 k+1개이다. 이때 노드의 키는 정렬되어있다. B+tree는 B-Tree의 단점을 개선한 자료구조이다. 단말 노드만 데이터를 저장하며, 이들끼리 연결 리스트로 연결되어있다.

> 균형 트리는 단말 노드들이 모두 같은 레벨을 유지하는 트리를 말한다.

### B-Tree에 비교하여 B+Tree의 장점과 단점에 대해 설명해주세요?

B+Tree의 장점은 첫번째, B-Tree보다 높이가 낮아져 검색에 효율적이다. B+Tree에서는 단말 노드만 데이터를 저장하므로 내부 노드가 자식 노드에 대한 포인터를 더 많이 유지할 수 있기 때문이다. 두번째, 테이블을 전체 탐색할 경우 B-Tree는 모든 노드를 탐색해야하지만 B+Tree는 연결 리스트를 선형 탐색하기만 하면 된다. B+Tree에서는 단말 노드가 링크드 리스트로 연결되어있기 때문이다. 세번째, 앞선 이유로 B+Tree는 부등호로 데이터를 순차적으로 검색해야하는 경우 더 효율적이다. B+Tree의 단점은 특정 키에 접근하려면 단말 노드까지 접근해야한다는 것이다.

## 트랜잭션

### 트랜잭션이란 무엇인가요?

트랜잭션은 데이터베이스에서 작업의 단위이다. 하나 이상의 SQL문이 원자적으로 실행된다.

### 트랜잭션의 특징은 무엇인가요?

트랜잭션의 특징은 ACID(원자성, 일관성, 고립성, 지속성)이다. 원자성(Atomicity)은 트랜잭션 내의 모든 연산이 모두 실행되거나 실행되지 않아야한다는 성질이다. 일관성(Consistency)은 트랜잭션 이전과 이후에도 데이터베이스가 일관성 있는 상태를 유지해야한다는 성질이다. 고립성(Isolation)은 트랜잭션이 갱신하고 있는 데이터는 트랜잭션 완료 전까지 다른 트랜잭션이 접근할 수 없다는 성질이다. 지속성(Durability)은 트랜잭션이 완료되면 이 갱신 사항이 데이터베이스에 영구히 반영되어야한다는 성질이다.

### 데이터베이스가 일관성 있는 상태를 유지한다는 것은 어떤 의미인가요?

데이터베이스가 무결성 제약조건을 위배하지 않는 상태를 말한다.

### 트랜잭션에서 COMMIT과 ROLLBACK이란 무엇인가요?

`COMMIT`과 `ROLLBACK`은 데이터베이스가 일관성 있는 상태를 유지하도록 한다. `COMMIT`은 트랜잭션이 완료되었으며 이 변경사항이 데이터베이스에 반영되었음을 나타낸다. `ROLLBACK`은 트랜잭션의 변경사항이 일부만 데이터베이스에 반영된 경우, 데이터베이스를 트랜잭션이 수행되기 전의 상태로 되돌리는 것이다.

### 시스템이 고장나면 어떻게 복구할 수 있을까?

시스템이 고장나기 전 트랜잭션이 완료된 경우와 그렇지 않은 경우로 나누겠다. 시스템이 고장나기 전 트랜잭션이 완료된 경우, 트랜잭션이 완료되었지만 데이터베이스에 반영되지 않을 수 있으므로 트랜잭션은 재수행(`REDO`)하여 일관성을 유지한다. 시스템이 고장나기 전 트랜잭션이 완료되지 않은 경우, 데이터베이스에 반영되었을 가능성이 있는 갱신 사항을 취소(`UNDO`)하여 일관성을 유지한다.

## 트랜잭션 격리 수준

> 참고
>
> - [쉬운코드 - transaction isolation level 설명합니다! isolation이 안될 때 나타날 수 있는 여러 현상들과 snapshot isolation도 같이 설명합니다!!](https://youtu.be/bLLarZTrebU?feature=shared)

### ACID 원칙을 완벽히 지키면 성능이 매우 떨어진다. 어떻게 보완할 수 있을까?

트랜잭션 격리 수준을 통해 동시성과 데이터 일관성의 트레이드 오프를 조절한다.

### 트랜잭션 격리 수준이란 무엇인가?

트랜잭션 격리 수준이란 한 트랜잭션이 다른 트랜잭션과 고립되어야하는 정도이다. 고립 수준이 낮으면 동시성은 높아지지만 데이터 일관성은 떨어진다. 고립 수준이 높으면 데이터 일관성은 높아지지만 동시성은 낮아진다.

### 트랜잭션 격리 수준은 어떻게 구현하나요?

lock 기법으로 구현할 수 있다. 데이터를 읽을 때 트랜잭션 범위에 따라 서로 다른 범위에 shared-lock을 걸어 다른 트랜잭션이 동시에 read할 수는 있지만 write는 할 수 없도록 한다. 데이터를 write할 때는 트랜잭션이 끝날 때까지 독점 lock을 걸어 다른 트랜잭션이 동시에 read, write할 수 없도록 한다.

###  낮은 트랜잭션 격리 수준을 사용할 때 어떤 문제가 발생할 수 있나요?

Dirty Read, Non Repeatable Read, Phantom Read가 있다. Dirty Read는 커밋되지 않은 트랜잭션에 의한 변경사항을 다른 트랜잭션이 읽는 경우이다. Non Repeatable Read는 동일한 SELECT문을 두 번 실행하는 사이 다른 트랜잭션이 수정 연산이나 삽입 연산을 수행해 다른 질의 결과가 나오는 경우이다. Phantom Read는 동일한 SELECT문을 두 번 실행하는 사이 다른 트랜잭션이 삽입 연산을 수행해 질의 결과에 새로운 레코드가 포함되는 경우이다.

### 트랜잭션 격리 수준의 종류에 대해 설명해주세요?

READ UNCOMMITED 수준에서는 트랜잭션이 공유 락을 걸지 않고 데이터를 읽는다. Dirty Read, Non Repeatable Read, Phantom Read가 발생할 수 있다. READ COMMITED 수준에서는 트랜잭션이 공유 락을 걸고 데이터를 읽은 후 바로 해제한다. Non Repeatable Read, Phantom Read가 발생할 수 있다. Repeatable READ 수준에서는 트랜잭션이 레코드에 공유 락을 걸고 트랜잭션이 끝나기 전까지 소유한다. Phantom Read가 발생할 수 있다. SERIALIZABLE 수준에서는 트랜잭션이 끝나기 전가지 다른 트랜잭션에 삽입, 수정, 삭제가 불가능하다. 트랜잭션이 순차적으로 실행되는 것과 같다. 동시성이 매우 떨어진다.

## MVCC

> 참고
>
> - [쉬운코드 - LOCK을 활용한 concurrency control 기법을 배워봅니다. 2PL(two-phase locking)도 같이 설명드려요~](https://youtu.be/0PScmeO3Fig?feature=shared)
> - [쉬운 코드 - (1부) MVCC 개념 설명합니다 ! MVCC가 각각의 isolation level에서 어떻게 동작하는지도 MySQL & postgreSQL 예제와 함께 설명합니다](https://youtu.be/wiVvVanI3p4?feature=shared)
> - [MVCC란?](https://velog.io/@yangsijun528/MVCC-란)
> - [[DATABASE\] MVCC 구조와 이해](https://mozi.tistory.com/561)
> - [동시성 제어](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=363)

### DBMS에서 동시성을 제어하기 위해 어떤 기법을 사용하는가?

lock 기법을 사용하거나 MVCC를 사용한다.

### MVCC는 무엇인가요?

MVCC(Multi-Version Concurrency Content)는 데이터를 여러 버전으로 저장하여 동시성을 제어하는 기법이다.

### MVCC의 장단점은 무엇인가요?

MVCC의 장점은 데이터의 일관성을 유지하면서 write와 read를 할 수 있어 동시성이 높아진다. 단점은 첫번째, 여러 버전의 데이터를 저장할 추가 공간을 필요로 한다. 두번째, 사용하지 않는 버전을 정리할 시스템이 필요하다. 세번째, 버전 충돌은 애플리케이션 수준에서 처리해야한다.

### MVCC에서 트랜잭션은 데이터의 버전을 어떻게 선택하나요?

MVCC에서 트랜잭션은 특정 시점을 기준으로 가장 최근에 커밋된 데이터를 읽는데, 이 특정 시점은 트랜잭션 격리 수준에 따라 다르다.(READ UNCOMMITED인 경우는 다루지 않는다.) READ COMMITED인 경우 read를 시작하는 시각을 기준으로 가장 최근에 커밋된 데이터를 읽는다. Repeatable READ와 SERIALIZABLE인 경우 트랜잭션을 시작하는 시각을 기준으로 가장 최근에 커밋된 데이터를 읽는다.

### MVCC를 사용했을 때 데이터 일관성에 문제가 생기는 예시를 설명해주세요

두 트랜잭션 A, B의 격리 수준이 read committed라고 하자. A는 1번부터 10번 레코드를 읽어 총합을 구한다. B는 3번, 7번 레코드에 10씩 더한다. 현재 1번부터 10번 레코드에는 100씩 들어있다. A는 순차적으로 레코드에 공유 lock을 걸고 값을 읽은 후 해제하며 6번까지 읽었다. 이때 B가 3번에 독점 lock을 걸고 10을 더한 후 7번에 독점 lock을 걸고 10을 더했다. B는 연산이 끝났으므로 커밋하고 독점 lock을 해제한다. A는 7번의 독점 lock이 해제되었으므로 10을 더한 7번을 읽는다. 어느 순간에도 레코드의 총합은 1010이 아니었으나, 트랜잭션 A는 일관성이 없는 값을 구하였다.

### lost update 문제에 대하여 알고 있나요? MVCC에서 발생할 수 있는 예시를 들어보세요.

lost update는 갱신한 사항이 소실되는 문제이다. 트랜잭션 격리 수준이 read committed인 트랜잭션 A와 B가 있다고 하자. A는 x에 20을 더하려한다. B는 x에 70을 더하려한다. 먼저 A가 x에 shared lock을 걸고 30으로 읽었다. 동시에 B가 x에 shared lock을 걸고 30으로 읽었다. B는 x를 변경하기 위해 독점 lock을 걸고 x를 30에서 100으로 갱신하고 별도의 공간에 저장한다. B는 연산을 마치고 변경 사항을 커밋한다. 데이터베이스에 x=100이 저장된다. 독점 lock을 기다리던 A는 독점 lock을 획득하고 x를 30에서 50으로 갱신하고 별도의 공간에 저장한다. A는 연산을 마치고 변경 사항을 커밋한다. 데이터베이스에 x=50이 저장된다. 즉, B가 x를 100으로 갱신한 사항이 소실되었다.

## SQL 문법

### SQL문에서 `WHERE`, `GROUB BY`, `HAVING`, `ORDER BY`의 순서는 어떻게 되나요?

`WHERE` -> `GROUP BY` -> `HAVING` -> `ORDER BY` 순이다.

예) `STUDENT` 테이블이 주어질 때, 반마다 여학생의 평균 성적을 보여주되, 평균 성적이 70점만 넘는 반을 오름차순으로 나열한다.

```sql
SELECT CNO, AVG(SCORE) AS AVGSCORE
FROM STUDENT
WHERE SEX='WOMAN'
GROUP BY CNO
HAVING AVG(SCORE) >= 70
ORDER BY AVGSCORE;
```

### 조인의 종류에 대해 말해주세요?

(왼쪽 테이블의 튜플 개수는 `N`, 오른쪽 테이블의 튜플 개수는 `M`이다.)

Inner Join은 두 테이블을 교집합하는 것이다. 일치하는 튜플 `K`개를 반환한다. Left Outer Join은 왼쪽 테이블을 기준으로 조인한다. `N`개의 튜플을 반환한다. Right Outer Join은 오른쪽 테이블을 기준으로 조인한다. `M`개의 튜플을 반환한다. Full Outer Join은 두 테이블을 합집합하는 것이다. `N+M-K`개의 튜플을 반환한다. Cross Join은 두 테이블을 곱집합하는 것이다. 총 `N*M`개의 튜플을 반환한다.