# javascript

> 질문과 답변은 [이 레포지토리](https://github.com/leegwae/study-javascript/tree/main)에 정리된 텍스트에 기반합니다. 자세한 내용은 해당 레포지토리를 참고하세요.
> **대부분 <u>모던 자바스크립트 Deep Dive(이웅모 저)</u>에 기반하여 정리되어있습니다. 해당 도서를 참고하세요.**

## TOC

- [변수와 스코프](#변수와-스코프)
- [객체와 원시값](#객체와-원시값)
- [자바스크립트 연산자](#자바스크립트-연산자)
- [자바스크립트 객체](#자바스크립트-객체)
- [자바스크립트 함수](#자바스크립트-함수)
- [상속과 프로토타입](#상속과-프로토타입)
- [실행 컨텍스트](#실행-컨텍스트)
- [자바스크립트비동기](#자바스크립트-비동기)
- [모듈 시스템](#모듈-시스템)
- [이터러블과 제너레이터](#이터러블과-제너레이터)
- [DOM](#DOM)
- [DOM 이벤트](#DOM-이벤트)
- [기타](#기타)
- [TypeScript](#TypeScript)

## 변수와 스코프

### 표현식과 문의 차이는 무엇인가요?

표현식은 값으로 평가되는 문으로, 평가된 값과 동치이다. 문은 값으로 평가되지 않는다.

### 자바스크립트에서 변수 선언 과정을 설명해주세요?

자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다. 선언 단계는 실행 컨텍스트에 변수 이름을 등록하는 과정으로 런타임 이전에 실행된다. 초기화 단계는 변수를 `undefined`로 초기화하는 과정으로 `var`로 선언한 경우 런타임 이전에, `let`과 `const`로 선언한 경우 런타임 이후에 실행된다.

### 호이스팅에 대해 설명해주세요?

호이스팅은 선언이 자신이 속한 스코프의 최상단으로 끌어올려지는 것을 말한다. 자바스크립트 엔진은 코드를 평가한 후 한줄씩 실행하는데, 이때 평가 과정에서 모든 변수 선언문, 함수 선언문을 찾아내 실행한다. 이를 선언이 끌어올려졌다고 하며 호이스팅이라고 하는 것이다.

### `var`, `let`, `const`의 차이점에 대해서 설명해주세요?

`var`는 재선언과 재할당이 가능한 변수를 선언한다. `let`은 재할당이 가능한 변수를 선언한다. `const`는 재선언과 재할당이 불가능한 변수를 선언한다. `var`는 함수 레벨 스코프를 가지나 `let`과 `const`는 블록 레벨 스코프를 가진다.

### TDZ에 대해 설명해주세요?

TDZ(temporal dead zone)은 식별자를 선언한 이후 초기화하기 전까지 참조할 수 없는 구간을 말한다. 자바스크립트 엔진은 선언하지 않은 식별자나 초기화 이전의 식별자에 접근하면 `ReferenceError`를 발생시킨다.

#### 다음 자바스크립트 코드를 실행하면 어떻게 될까요?

```javascript
let b = 1;
{
  console.log(b);
  let b = 2;
}
```

`RefereneceError`가 발생한다. 블록 내부의 변수 `b`의 선언은 호이스팅되어 런타임 이전에 선언 단계가 실행되었다. 그러나 `let`으로 선언되었으므로 런타임 이전에 `undefined`로 초기화되지 않았다. 따라서 `console.log`에서 접근하고 있을 때는 `b`가 TDZ에 속하므로 `RefereneceError`를 발생시킨다.

#### 아래 alert 결과값은?

```javascript
var foo = "Hello";
(function() {
  var bar = " World";
  alert(foo + bar);	// Hello World
})();
alert(foo + bar);	// ReferenceError
```

### `null`과 `undefined`, undeclared의 차이점에 대해 설명해주세요?

undeclared는 선언되지 않은 상태이다. `undefined`는 선언되어 자바스크립트 엔진에 의해 `undefined`로 초기화된 상태이다. `null`은 명시적으로 빈 값을 할당한 상태이다.

### 자바스크립트의 스코프에 대해 설명해주세요?

일반적으로 스코프는 식별자를 참조할 수 있는 유효범위를 뜻한다. 자바스크립트의 스코프는 렉시컬 스코프로, 함수 정의가 평가되는 시점에 그 함수의 상위 스코프를 정적으로 결정한다. 자바스크립트 엔진은 내부적으로 렉시컬 환경(Lexical Environment)이라는 자료구조를 통해 스코프를 관리한다.

### 자바스크립트의 스코프 체인에 대해 설명해주세요?

스코프 체인은 내부적으로 렉시컬 환경을 연결한 것으로, 자바스크립트 엔진은 스코프 체인을 통해 상위 스코프 방향으로 이동하며 식별자를 검색한다.

> 렉시컬 환경은 내부적으로 환경 레코드(Environment Record)에 대한 참조이다. 이 환경 레코드의 `[[OuterEnv]]` 필드가 상위 렉시컬 환경을 참조해 이것이 스코프 체인을 구성하고 있다.

## 객체와 원시값

### 자바스크립트의 동적 타이핑에 대해 설명해주세요?

자바스크립트에서 변수의 타입은 값을 할당하는 시점에 동적으로 결정된다.

### 자바스크립트 원시 값의 종류에는 어떤 게 있는가?

ES11 기준 7가지이다. number, string, boolean, null, undefined, symbol, bigint이다.

### 자바스크립트에서 원시 값과 객체의 차이에 대해 설명해주세요?

첫번째, 원시 값은 변경 불가능한 값이나 객체는 변경 가능한 값이다. 두번째, 원시값은 메모리 공간에 실제 값이 저장되나 객체는 메모리 공간에 객체가 저장된 메모리 공간의 주소인 참조 값이 저장된다.

### 자바스크립트에서 객체는 왜 변경 가능한 값일까요?

객체는 프로퍼티를 동적으로 추가할 수 있어 원시값보다 많은 메모리와 비용을 소모한다. 원시 값처럼 매번 복사하여 새로운 메모리 공간을 할당하는 것은 비효율적이다. 따라서 변수에 객체 자체가 아니라 참조값을 저장하여 비용을 줄인다.

### `Symbol`에 대해 설명해주세요?

Symbol은 유일하고 변경 불가능한 원시 값이다. 대개 유일한 이름의 프로퍼티 키를 만들기 위해 사용한다. 객체의 프로퍼티로 well-known symbol을 사용하면 객체의 동작을 정의할 수 있다. 예를 들어 `Symbol.iterator` well-known symbol을 키로 메서드를 정의하면 해당 객체를 이터러블하게 만들 수 있다.

### 자바스크립트 형 변환에 대해 설명해주세요?

자바스크립트에서 형 변환은 암묵적 형 변환과 명시적 형 변환이 있다. 전자는 자바스크립트 엔진에 의해 암묵적으로 이루어진다. 예를 들어 조건문의 조건식에서 값은 `boolean` 값으로 평가된다. 후자는 프로그래머가 명시적으로 형변환하는 것이다. 예를 들어 빌트인 생성자를 `new` 없이 호출하는 경우가 속한다.

### 자바스크립트에서 객체를 원시 값으로 변환할 수 있는가?

변환할 수 있다. 객체는 hint를 기준으로 원시 값으로 변환된다. 문자열로 변환되기를 기대하는 연산에서 hint는 `"string"`, 숫자로 변환되기를 기대하는 연산에서는 `"number"`, 그 외의 경우는 `"default"`이다. 예를 들어 단항 더하기 연산에서 hint는 "number"이다. 자바스크립트 엔진은 우선 객체 내부에 `Symbol.toPrimitive` 메서드를 찾아 hint를 인자로 호출하고 없다면 `toString()`이나 `valueOf()` 메서드를 실행한다. 이때 최종 반환값이 원시값이 아니라면 `TypeError`를 발생시킨다.

> 참고
>
> - [자바스크립트에서 객체를 원시값으로 변환하기](https://github.com/leegwae/study-javascript/blob/main/Conversion%20Object%20to%20Primitive%20Value.md)

### 자바스크립트 배열은 실제 자료구조 배열이 아니다. 그 이유는 무엇인가?

우선 배열을 동일한 데이터 타입의 값들을 순차적으로 저장한 유한한 크기의 자료구조로 정의하겠다. 이에 비하여 자바스크립트 배열은 요소들이 서로 다른 데이터 타입을 가질 수 있으며 동적으로 크기를 조절할 수 있다. 또한 자바스크립트 엔진은 내부적으로 최적화를 통해 희소 배열의 경우 딕셔너리 형태로 관리한다.

## 자바스크립트 연산자

### 동등 연산자(`==`)와 일치 연산자(`===`)의 차이에 대해 설명해주세요?

동등 연산자는 암묵적 타입 변환한 후 같은 값으로 평가되었는지 비교하고 일치 연산자는 암묵적 타입 변환하지 않고 같은 값으로 평가되었는지 비교한다.

### 단축 평가(short evaluation)에 대해 설명하고, 자바스크립트에서 예시를 들어주세요?

표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것이다. 예를 들어 논리 OR 연산자(`||`)에서 첫번째 피연산자의 평가 값이 `true`이면 두번째 피연산자는 평가하지 않는다.

### `'1' + 1`과 `'1' - 1` 결과값은?

`'1' + 1`은 `2`이고 `'1' - 1`은 `0`이다. 자바스크립트는 이항 `+` 연산에서 피연산자에 문자열이 있다면 string concatenation하기 때문이다. `-` 연산은 피연산자를 숫자 타입으로 변환한 후 연산한다.

## 자바스크립트 객체

### 전역 객체와 호스트 객체, 빌트인 객체의 차이에 대해 설명해주세요?

전역 객체는 빌트인 객체, 호스트 객체, `var`로 선언한 전역 변수와 암묵적 전역, 전역 함수를 프로퍼티로 가진다. 호스트 객체는 런타임에서 추가적으로 제공하는 객체이다. 예를 들어 브라우저 환경에서 호스트 객체는 DOM, Canvas, `fetch` 등이 있다. 빌트인 객체는 자바스크립트 명세에 정의되어 자바스크립트 엔진이 제공하는 생성자 함수이다.

### 내부 메서드와 내부 슬롯이란 무엇인가?

내부 메서드는 ECMAScript 명세에서 객체의 런타임 동작을 설명하는 알고리즘을 가리키기 위해 사용하는 용어이다. 예를 들어, 함수 객체는 `[[Call]]` 내부 메서드를 가지며 constructor 함수는 `[[Construct]]` 내부 메서드를 가질 수 있다. 내부 슬롯은 ECMAScript 명세에서 객체의 내부 상태를 가리키기 위해 사용하는 용어이다. 예를 들어, 객체는 `[[Prototype]]`이라는 내부 슬롯을 가진다.

### 프로퍼티 어트리뷰트란 무엇인가?

객체 프로퍼티의 상태를 나타내는 내부 슬롯이다. 예를 들어 데이터 프로퍼티는 프로퍼티의 값을 나타내는 `[[Value]]` 어트리뷰트와 프로퍼티가 열거가능한지 나타내는 `[[Enumerable]]` 어트리뷰트 등을 가진다.

## 자바스크립트 함수

### 자바스크립트 함수에 대해서 알려주세요?

자바스크립트의 함수는 호출 가능한 객체이다. 또한 일급 객체로서 값으로 사용될 수 있다(다른 함수의 인수로 전달되거나 반환값이 될 수 있다).

### 일반 객체와 함수의 차이에 대해 알려주세요?

함수는 호출 가능한 객체로 일반 객체가 가지는 내부 슬롯과 내부 메서드에 더하여 추가적인 내부 메서드와 내부 슬롯(`[[Call]]`, `[[Environment]]` 등)을 가진다.

### `function foo(){}();` 이 코드는 왜 IIFE로 동작하지 않나요? IIFE로 만들려면 어떻게 해야할까요?

함수 선언문은 값으로 평가되지 않기 때문이다. `function foo(){}`가 함수 객체로 평가되지 않으니 `()`를 붙여도 함수 호출로 평가되지 않고 `SyntaxError`를 발생시킨다. 이를 해결하려면 함수 선언문 자리에 익명 함수 표현식이나 화살표 함수 표현식을 `()`로 감싸 함수 객체로 평가되도록 한다. `(function (){})();` 혹은 `(() => {})();`

### constructor와 non-constructor란 무엇인가?

자바스크립트에서 constructor는 함수 선언문, 함수 표현식, 클래스로 정의한 함수이다. non-constructor는 메서드와 화살표 함수이다. constructor는 추가적으로 내부 메서드 `[[Construct]]`를 가진다. 

### 인스턴스 생성 과정에 대해 알려주세요?

constructor가 생성자 함수로서 호출되면 첫번째, 인스턴스를 생성하고 `this`에 바인딩한다. 두번째, 인스턴스를 초기화한다. 세번째, 암묵적으로 인스턴스가 바인딩된 `this`를 반환한다.

### 화살표 함수와 일반 함수의 차이에 대해 설명해주세요?

화살표 함수는 non-constructor이며 자체적으로 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않는다. 이들은 스코프 체인을 통해 상위 스코프의 `this`, `arguments`, `super`, `new.target`을 참조한다.

### `this`는 JavaScript에서 어떻게 작동하는가?

`this`는 전역 문맥에서는 전역 객체를 참조한다. 함수 문맥에서는 함수가 호출되는 방식에 따라 달라진다. (1) 일반 함수로 호출되면 전역 객체이다. 단, 엄격 모드의 경우 `undefined`이다. (2) 메서드로 호출되면 메서드를 호출한 객체이다. (3) 생성자 함수로 호출되면 생성자 함수가 생성할 인스턴스이다. (4) 화살표 함수에서 `this`는 렉시컬로 스코프 체인을 통해 검색한다.

### `Function.prototype.call/apply/bind`의 차이에 대해 알려주세요?

`call`과 `apply`는 지정한 `this`의 값으로 함수를 호출한다. `bind`는 `this`의 값이 고정된 함수를 반환한다.

### Closure에 대해 설명해주세요?

중첩 함수가 외부 함수보다 더 오래 유지되며, 외부 함수의 변수를 참조하는 경우 이 중첩 함수를 클로저(Closure)라고 한다.

## 상속과 프로토타입

### 자바스크립트에서 상속은 어떻게 이루어지는가?

상속은 프로토타입 체인을 통해 이루어진다. 모든 객체는 자신의 프로토타입 객체를 가리키는 내부 슬롯 `[[Prototype]]`을 가져 이것이 프로토타입 체인을 구성한다. 자바스크립트 엔진은 프로퍼티에 접근하면 프로토타입 체인을 통해 상위 프로토타입으로 이동하며 프로퍼티를 검색한다. 객체의 프로토타입은 `Object.prototype.__proto__` 프로퍼티 혹은 ES5의 `Object.prototype.getPrototypeOf` 메서드로 접근할 수 있다.

### 프로토타입의 생성 시점은 언제인가요?

프로토타입은 생성자가 생성되는 시점, 즉 런타임 이전에 생성된다. 빌트인 생성자 함수와 그 프로토타입은 전역 객체가 생성되는 시점에, 사용자 정의 생성자 함수와 그 프로토타입은 함수 정의가 평가되는 시점에 생성된다.

### 객체의 프로토타입은 어떻게 결정되나요?

프로토타입 객체는 객체를 생성하는 방식에 따라 달라진다. 객체 리터럴로 생성되었다면 `Object.prototpye`이다. 함수 리터럴로 생성되었다면 `Function.prototype`이다. 생성자 함수로 생성되었다면 해당 생성자 함수의 `prototype` 프로퍼티가 가리키는 객체이다. 생성자 함수 객체의 프로토타입은 `Function.prototype`이다.

### 정적 메서드와 프로토타입 메서드의 차이는 무엇인가?

정적 메서드는 생성자 함수 객체의 프로퍼티로 생성자 함수 객체를 통해 호출하고, 프로토타입 메서드는 프로토타입 객체의 프로퍼티로 인스턴스를 통해 호출한다. 정적 메서드는 인스턴스의 프로퍼티를 참조할 수 없다.

### `super` 키워드에 대해 알려주세요?

`super` 키워드는 메서드 내부에서 자신을 바인딩한 객체의 프로토타입 객체에 접근할 때 사용한다. 메서드는 내부적으로 자신을 바인딩하는 객체를 `[[HomeObject]]` 내부 슬롯으로 참조하는데, `super`는 `[[HomeObject]].__proto__`로 자신을 바인딩한 객체의 프로토타입 객체에 접근할 수 있다.

## 실행 컨택스트

### 실행 컨텍스트에 대해 설명해주세요?

실행 컨텍스트(Execution Context)는 자바스크립트 코드가 평가될 때마다 생성되어 평가된 코드를 실행하기 위한 스코프를 관리한다. 실행 컨텍스트는 렉시컬 환경을 유지하는데, 렉시컬 환경(Lexical Environment)은 환경 레코드에 대한 참조이다. 환경 레코드(Environment Record)에 식별자 바인딩을 기록하고 있으며, 이 환경 레코드는 외부 환경 레코드에 대한 참조를 가져 스코프 체인을 생성한다.

### 실행 컨텍스트 스택에 대해 설명해주세요?

실행 컨텍스트 스택은 코드의 실행 순서를 관리하는 자료구조이다. 엔진은 항상 스택의 top에 있는 실행 컨텍스트를 실행한다.

## 자바스크립트 비동기

### 자바스크립트의 동시성 모델에 대해 설명해주세요? (자바스크립트는 싱글 스레드인데 어떻게 비동기 작업을 처리할 수 있나요?)

(자바스크립트는 이벤트 루프에 기반하여 동시성을 지원하고 있다.) 자바스크립트 엔진은 싱글 스레드이지만 자바스크립트 엔진은 탑재한 런타임이 이벤트 루프로 비동기 작업을 지원한다. 브라우저 기준으로 이벤트 루프(event loop)는 콜백 큐(callback queue)를 가지고 있어 엔진의 콜 스택을 확인한 후 콜 스택이 비어있으면 큐에서 대기중인 함수를 콜 스택으로 이동하는 작업을 반복한다.

#### 더 자세히 설명해주세요?

이벤트 루프의 콜백 큐는 비동기 함수의 콜백과 이벤트 핸들러를 보관하는 태스크 큐(task queue)와 `Promise` 프로토타입 메서드와 `MutationObserver`의 콜백을 보관하는 마이크로태스크 큐(microtask queue)로 나뉜다. 이벤트 루프는 마이크로태스크 큐에서 우선 함수를 꺼내고 비게 되면 태스크 큐에서 함수를 꺼내어 콜 스택에 푸쉬한다. 브라우저가 제공하는 비동기 API의 경우 각각의 API를 처리하는 멀티스레드에서 실행된 후 콜백이 태스크 큐에 푸쉬된다.

### `requestAnimationFrame(rAF)`에 대해 설명해주세요?

애니메이션이나 그 외의 작업을 반복하기 위해 사용하는 Web API로, 브라우저 리페인트 이전에 전달한 콜백을 호출한다. 내부적으로는 이벤트 루프의 `animation frame`이라는 큐에서 처리되고 있다.

### `setTimeout`이나 `setInterval`과 같은 타이머 API 대신 `rAF`를 사용하는 이유는 무엇일까요?

첫번째로 브라우저가 리페인트 주기와 동기화하여 `rAF`를 실행하므로 렌더링 주기에 상관없이 동작하는 타이머 함수를 사용했을 때보다 더 정확한 애니메이션을 제공한다. 두번째로 브라우저 내부적으로 애니메이션을 최적화한다. 세번째로 백그라운트 탭에서는 실행을 중단하여 배터리 수명을 절약하고 성능을 향상한다.

> 참고
>
> - https://www.jeong-min.com/36-RAF/
> - https://inpa.tistory.com/entry/%F0%9F%8C%90-requestAnimationFrame-%EA%B0%80%EC%9D%B4%EB%93%9C

### 자바스크립트 비동기 프로그래밍에 대해 알려주세요?

자바스크립트에서 비동기는 콜백 패턴과 ES6 `Promise`/ES8 `async`와 `await`를 사용하여 처리할 수 있다. 콜백 패턴은 전통적인 방식으로 콜백 함수를 사용한다. 프로미스는 빌트인 객체 `Promise`를 사용한다.

### `Promise`에 대해 알려주세요?

프로미스는 비동기 로직을 구현한 함수를 전달받는다. 이 함수는 `resolve`와 `reject` 함수를 파라미터로 전달받는데 각각 비동기 처리가 성공하거나 실패할 때 원하는 값을 전달하여 호출한다. `resolve`와 `reject` 함수를 호출하기 전까지 프로미스는 `pending` 상태를 유지한다.

### `Promise`의 상태에 대해 알려주세요?

비동기 처리가 완료되지 않은 상태인 `pending`, 비동기 처리가 완료된 상태인 settled로 나눌 수 있다. 이때 settled는 비동기 처리가 성공으로 완료되었다면 `fulfilled` 상태로, 실패로 완료되었다면 `rejected` 상태로 나눌 수 있다.

### 콜백 패턴에 비해 `Promise`의 장점은?

첫번째, 콜백 지옥을 피할 수 있다. 두번째, `Promise.all`을 사용하면 병렬적으로 비동기 코드를 처리할 수 있다.

### 콜백, 프로미스, async/await의 차이에 대해 말씀해주세요?

콜백은 콜백 함수를 바탕으로 한다. 프로미스는 ES6 프로미스 객체 기반한다. ES8 async/await는 프로미스 기반하는 키워드다.

#### 어떨 때 어떤 패턴을 사용하는가?

콜백 패턴은 보통 DOM에 이벤트 리스너 등록할 때 쓴다. 프로미스는 직접 비동기 로직을 작성해서 프로미스의 상태를 바꿔줄 때 사용하겠다. async/await는 비동기 함수를 동기적으로 호출할 때 사용할 것이다.

### Ajax에 대해 아는 대로 설명해주세요?

Ajax(Asynchronous JavaScript and XML)는 Web API인 `XMLHttpRequest`에 기반하여 서버와 브라우저가 비동기적으로 데이터를 주고받는 통신 방법이다. Ajax 이전까지는 브라우저는 서버와 동기적으로 통신하여 클라이언트는 서버의 응답을 받을 때까지 블로킹되었다. 또한 브라우저는 서버로부터 완전한 HTML을 전송받아 렌더링하는 서버사이드 렌더링을 사용하여, 사용자가 화면을 전화하면 새로운 완전한 HTML을 전송받아 다시 처음부터 렌더링했다. 따라서 변경할 필요가 없는 부분도 다시 전송받아 렌더링해야했고, 순간적으로 깜빡이는 현상이 발생했다. Ajax 이후 브라우저와 서버는 비동기적으로 통신할 수 있게 되었다. 브라우저는 서버로부터 필요한 부분만 전송받아 렌더링하는 클라이언트 사이드 렌더링을 사용한다.

## 모듈 시스템

> 참고
>
> - [ES Module Deep Dive 정리](https://github.com/leegwae/study-javascript/blob/main/ECMAScript%20Module.md)
> - [ES Module Deep Dive 번역](https://github.com/leegwae/study-javascript/blob/main/ES%20Module%20Reference.md)
> - [자바스크립트 모듈 시스템 정리](https://github.com/leegwae/study-javascript/blob/main/Module.md)

### ESM 이전 자바스크립트 모듈 시스템에 대해 아는 대로 설명해주세요?

모듈 시스텝 도입 이전 자바스크립트 스크립트는 독자적인 스코프를 가지지 않았다. 이름 충돌이 발생하고 의존성이 있는 모듈 간의 로드 순서를 고려해야하는 문제가 발생했다. ES6 네이티브 자바스크립트 모듈 시스템이 등장하기 전까지는 CommonJS, AMD, UMD 등 모듈 시스템을 정의하려는 집단이 있었다. CommonJS는 서버사이드 환경을 전제로 하여 동기적인 모듈 로더를 사용한다. AMD는 CommonJS에서 독립한 집단으로 비동기적으로 모듈을 로딩하여 서버사이드, 브라우저 모두에서 운용가능하다. 이후 ESM의 `import` 구문에 영향을 미친다. UMD는 여러 모듈 시스템의 호환을 제공하는 패턴으로 내부적으로는 분기이다.

### ECMAScript Module이 동작하는 방식을 알려주세요?

ESM은 파일 단위로 각각의 파일이 독립적인 모듈 스코프를 가진다. 브라우저에서는 `<script type="module">`로 스크립트를 모듈로 지정할 수 있다. 자바스크립트는 모듈인 스크립트를 실행하면 스크립트를 정적 분석하여 해당 스크립트를 진입점으로 한 모듈 그래프를 만든다. 이 과정을 모듈 로딩이라고 하며 구성, 인스턴스화, 평가 단계로 이루어진다. `구성 단계`는 fetching과 parsing으로 이루어진다. fetching은 모듈 로더는 파일을 다운로드하고 모듈맵(module map)에 모듈을 캐싱하는 과정이다. parsing은 엔진이 파일을 파싱하여 import/export 정보를 가진 모듈 레코드(module record)를 생성하는 과정이다. 이때 모듈이 의존하는 다른 모듈에 대해 과정을 반복하여 그래프를 빌드한다. `인스턴스화 단계`에서 엔진은 모듈 레코드에 대하여 모듈 환경 레코드(module environment record)를 만들어 export된 값을 넣을 메모리 공간을 확보한다. 이후 모듈 그래프를 DFS하여 export와 import를 연결하는 작업을 반복한다. `평가 단계`에서 엔진은 진입점부터 DFS 순회하며 모든 모듈을 한 번씩 실행한다.

### 클래식 스크립트와 ESM의 차이에 대해 설명해주세요?

클래식 스크립트에 대하여 모듈은 첫번째, 언제나 strict mode에서 실행된다. 두번째, HTML 스타일의 주석을 허용하지 않는다. 세번째, 렉시컬 최상위 스코프를 가진다(var과 함수 선언문은 전역 객체의 프로퍼티가 되지 않는다). 네번째, 기본적으로 지연된다. 다섯번째, 처음 import될 때 한 번 평가되고 한 번 실행된다. 여섯번째, 최상위 await가 가능하다.

### CJS와 ESM의 차이에 대해 설명해주세요?

첫번째, CJS는 동기적으로, ESM은 비동기적으로 모듈을 로딩한다. 전자는 디스크로부터 모듈을 불러오는 서버사이드 환경을 전제하지만 ESM은 네트워크를 통해 모듈을 가져오는 환경을 전제하기 때문이다. 두번째, 앞선 이유로 CJS는 메인 스레드를 블로킹하는 시간이 길지 않지만 ESM은 많은 시간이 걸리기 때문에 모듈 로딩을 비동기적으로 실행될 수 있는 세 개의 단계로 나눈다. 세번째, CJS는 최상위 await를 지원하지 않지만 ESM은 지원한다. 그래서 CJS 로더는 ESM을 로딩할 수 없지만 ESM 로더는 CJS를 로딩할 수 있다. 네번째, CJS는 비교적 동적이며, ESM은 비교적 정적이다. CJS의 `require`나 `module.exports`는 런타임에 재정의가 가능하여 런타임 이전에 종속성을 파악할 수 없다. 그러나 ESM은 최상위에서만 정적 `import`문과 `export`문을 사용할 수 있어 런타임 이전에 정적 분석해 의존성 그래프를 빌드할 수 있다. 이러한 차이로 ESM은 트리쉐이킹이 용이하다. 다섯번째,CJS는 모듈의 런타임 변화를 추적하지 않으나 ESM은 라이브 바인딩하여 동일한 모듈은 항상 메모리 공간에서 동일한 위치를 가리킨다.

### Node.js에서 CJS와 ESM을 어떻게 상호 운용할 수 있는가?

정적 `import`문은 ESM이 ESM 혹은 CJS를 정적으로 불러올 때 사용할 수 있다. 동적 `import()`식은 ESM이나 CJS가 ESM 혹은 CJS를 동적으로 불러올 때 사용할 수 있다. `import`를 사용하여 named export한 CJS를 불러오는 경우에 한하여 Node.js가 정적 분석을 지원하여 named import할 수 있다. `require()`식은 CJS가 CJS를 불러올 때 사용할 수 있다.

## 이터러블과 제너레이터

### 지연 평가(Lazy Evaluation)에 대해 설명해주세요?

지연 평가는 값이 필요할 때까지 해당 값의 평가를 미루는 평가 방식이다. 자바스크립트에서 지연 평가는 이터러블로 구현할 수 있다. (아래 예시는 무한 피보나치 수열을 구현한 것이다.)

```javascript
const fibonacciFn = function () {
  let [pre, cur] = [0, 1];
  
  return {
    [Symbol.iterator]() { return this; },
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur };
    },
  };
};

const max = 10;
for (const num of iter) {
  if (num >= max) break;
  console.log(num);
}

const [f1, f2, f3] = fibonacciFn();
console.log(f1, f2, f3);	// 1 2 3

const fibo = fibonacciFn();
console.log(fibo.next().value);	// 1
console.log(fibo.next().value);	// 2
console.log(fibo.next().value);	// 3
```

### 이터러블과 이터레이터 프로토콜에 대해 설명해주세요?

`Symbol.iterator`을 호출하면 이터레이터를 반환하는 객체를 이터러블이라고 한다. `for...of`는 내부적으로 이터러블의 `Symbol.iterator`가 반환한 이터레이터를 사용하여 이터러블을 순회한다. `next` 메서드를 호출하면 이터레이터 리절트를 반환하는 객체를 이터레이터라고 한다. 이터레이터 리절트는 현재 순회중인 이터러블의 값을 나타내는 `value`와 순회 완료를 나타내는 `done` 프로퍼티를 가진다.

### 제너레이터에 대해 설명해주세요?

제너레이터(generator)는 이터러블이면서 이터레이터이다. 제너레이터의 `next` 메서드를 호출하면 함수 본문의 `yield` 표현식까지 코드를 실행하고 `value`가 `yield`한 값인 이터레이터 리절트를 호출자에게 반환한다. 또한 두번째 호출부터는 인자로 전달받은 값은 이전 `yield` 표현식의 평가값이 된다.

### 제너레이터로 무한 피보나치를 구현해보세요?

```javascript
function* fibonacciFn() {
  let [pre, cur] = [0, 1];
  
  while (true) {
    [pre, cur] = [cur, cur + pre];
    yield cur;
  }
}

const fiboGenerator = fibonacciFn();
console.log(fiboGenerator.next().value);	// 1
console.log(fiboGenerator.next().value);	// 2
console.log(fiboGenerator.next().value);	// 3
console.log(fiboGenerator.next().value);	// 5
console.log(fiboGenerator.next().value);	// 8
```

### `for...in`문과 `for...of`문의 차이는 무엇인가요?

`for...in`은 객체의 열거가능한 프로퍼티를 순회한다. `for...of`는 이터러블의 프로퍼티의 값을 순회한다.

## DOM

### DOM이란 무엇인가?

DOM은 HTML이나 XML 문서의 계층적 구조를 트리로 표현하고, 이를 제어할 수 있는 프로퍼티와 메서드를 제공하는 Web API이다. 브라우저의 렌더링 엔진은 HTML 문서를 구성하는 HTML Element를 파싱하여 DOM 노드로 변환한다. 이때 HTML Element는 Element 노드로, 어트리뷰트는 어트리뷰트 노드로, 컨텐츠는 Text Node로 변환된다.

### DOM 노드의 상속 구조에 대해 설명해주세요? 

```
Object <- EventTarget <- Node
	Node <- Document <- HTMLDocument
	Node <- Element
		Element <- HTMLElement
		Element <- SVGElement
	Node <- Attr
	Node <- CharacterData
		CharacterData <- Text
		CharacterData <- Comment
```

`HTMLElement`와 `SVGElement`는 `Element`를, `Element`는 `Node`를, `Node`는 `EventTarget`을, `EventTarget`은 `Object`를 상속받는다.

### HTML 어트리뷰트와 DOM 프로퍼티의 차이가 무엇인가요?

DOM 프로퍼티는 사용자와의 상호작용으로 변하는 어트리뷰트의 최신 상태를 저장하나, HTML 어트리뷰트는 어트리뷰트의 초기값을 저장한다.

> Element 노드는 DOM 프로퍼티들과 `attributes` 프로퍼티를 유지한다. DOM 프로퍼티는 HTML 어트리뷰트에 대응하고 `attributes` 프로퍼티는 어트리뷰트 노드들의 맵을 저장한다. 이는 DOM 프로퍼티가 사용자와의 상호작용으로 변하는 어트리뷰트의 최신 상태를 관리하고, 어트리뷰트 노드는 어트리뷰트의 초기 상태를 관리하기 위해서이다. 예를 들어 `<input value="hello">`에 대해서 이 HTML 태그가 파싱되어 만들어진 Element 노드의 `value` 프로퍼티는 초기값은 `"hello"`이나 사용자의 입력값에 따라 값이 변경되나, `value` 어트리뷰트는 초기값 `"hello"`를 유지한다. (한편, 모든 어트리뷰트와 프로퍼티가 일대일 대응하는 것은 아니다.)

## DOM 이벤트

### 이벤트 핸들러를 등록하는 방법에 대해 설명해주세요?

첫번째, 이벤트 핸들러 어트리뷰트에 등록하거나(`<button onClick="hello()" />`) 두번째, 이벤트 핸들러 프로퍼티에 등록하거나(`button.onClick=hello;`) 세번째, `EventTarget.prototype.addEventListener`으로 등록한다.

### 이벤트 버블링과 이벤트 캡처링에 대해 설명해주세요?

이벤트 버블링과 이벤트 캡처링은 이벤트가 전파되는 방식이다. 이벤트 캡처링은 이벤트가 최상위 요소부터 시작하여 이벤트 타겟까지 전파되는 것이다. 이벤트 버블링은 이벤트가 이벤트 타겟부터 최상위 요소까지 전파되는 것이다.

### 이벤트 위임에 대해 설명해주세요?

상위 요소에 이벤트의 처리를 위임하는 것이다. 예를 들어 리스트 내부에 여러 개의 리스트 아이템이 있을 때, 이 리스트 아이템에 각각 이벤트 핸들러를 달지 않고 리스트에 하나의 이벤트 핸들러만 달아 이벤트를 처리할 수 있다.

```html
<ul id="my-list">
  <li data-id="1">집 사기 <button>DELETE</button></li>
  <li data-id="2">돈 벌기 <button>DELETE</button></li>
  <li data-id="3">책 읽기 <button>DELETE</button></li>
</ul>
```

```javascript
document.getElementById('my-todo').addEventListener('click', (e) => {
  if (e.target.textContent === 'DELETE') removeTodo(e.target.dataset.id);
});
```

### `Event.prototype.currentTarget`과 `Event.prototype.target`의 차이에 대해 설명해주세요?

전자는 이벤트 핸들러가 등록된 요소를, 후자는 이벤트가 실제로 발생한 요소(이벤트 타겟)을 가리킨다.

### 스크롤 이벤트를 최적화하려면 어떻게 할 수 있을까요?

스로틀링을 사용하거나 `rAF`를 사용해보겠다.

### 스로틀링과 디바운싱에 대해 설명해주세요?

스로틀링은 이벤트가 여러 번 발생해도 일정 시간 내 최대 n번의 이벤트 핸들러를 호출하는 것이다. 예를 들어 게임에서 쿨타임이 있는 스킬은 해당 쿨타임이 지나야지만 다시 사용할 수 있다. 디바운싱은 이벤트가 발생한지 일정 시간이 지나야 핸들러를 호출하는 것이다. 예를 들어 사용자의 입력값에 따라서 추천 검색어를 보여준다고 하면, 매 입력마다 API를 호출하지 않고 입력 이벤트가 발생한지 1초가 지나야 API를 호출하도록 하는 것이다.

> 참고
>
> - https://css-tricks.com/the-difference-between-throttling-and-debouncing/

## 기타

### 자바스크립트에서 가비지 컬렉터의 동작을 알려주세요?

Mark and Sweep 알고리즘을 사용하여 가비지 컬렉션한다. 루트 객체(전역 변수, 전역 객체)로부터 시작해서 루트가 참조하는 모든 객체를 방문하여 `mark`하고, `mark`된 객체도 방문하여 도달 가능한 객체가 없을 때까지 `mark`하는 과정을 반복한다. 순회가 끝난 후 `mark`되지 않은 객체는 메모리에서 삭제한다. 일정 시간 이상 살아남은 객체는 새로운 세대에서 오래된 세대로 이동하여, 새로운 세대에 비해 가비지 컬렉션을 덜 실행한다. 

> 참고
>
> - https://ko.javascript.info/garbage-collection

### `use strict;`(stirct mode)에 대해 설명해주세요?

strict mode는 ES6 도입 이후 기존 기능에 변경된 사항을 활성화하고 오류를 발생시킬 수 있는 코드에 에러를 발생시킨다. (1) 암묵적 전역에 `ReferenceError`를 발생시킨다. (2) `delete`로 변수, 함수, 매개변수를 삭제하면 `SyntaxError`를 발생시킨다. (3) 함수를 일반 함수로 호출하는 경우 `this`의 값은 `undefined`이다.

- **`console.log(0.1 + 0.2 == 0.3);`의 값은 무엇인가?** `false`이다.
- **`"ab cd ef".split("").reverse().join("");`의 값은?** `'fe dc ba'`이다.

## TypeScript

> 참고
>
> - [[Typescript] unknown vs any type](https://roseline.oopy.io/dev/typescript-unknown-vs-any-type)

### TypeScript `unknown`과 `any`의 공통점과 차이점에 대해 말씀해주세요?

any나 unknown으로 선언된 변수는 어떠한 타입의 값이든 할당할 수 있으나, unknown 타입의 값은 any와 unknown 타입의 변수에만 할당할 수 있다.

### 언제 `any`를 쓰고 언제 `unknown`을 사용하나요?

any는 모든 타입의 값을 허용하려고 하여 타입 체킹을 하지 않을 때, unknown은 어떤 값을 가질지 확실하지 않아 타입 가드나 단언을 사용하도록 강제하기 위해 사용한다.